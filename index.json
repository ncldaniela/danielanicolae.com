[
{
	"uri": "https://danielanicolae.com/programare/",
	"title": "Programare",
	"tags": [],
	"description": "",
	"content": " Programare Resurse pentru a invata informatica "
},
{
	"uri": "https://danielanicolae.com/diverse/",
	"title": "Diverse",
	"tags": [],
	"description": "",
	"content": " Diverse Resurse diverse "
},
{
	"uri": "https://danielanicolae.com/diverse/ora_de_dirigentie/",
	"title": "Ora de Dirigentie",
	"tags": [],
	"description": "",
	"content": "  ORA DE DIRIGENTIE ON LINE:\nhttp://localhost/Login2.aspx?loginRedirect=/default.aspx http://ler.is.edu.ro/~oradedirigentie/siveco/index.php Informatii, exemple.. privind completarea unui CV http://www.europass-ro.ro\nGhid de prezentare la un interviu descarcat de aici http://www.europass-ro.ro/index.php?page=materiale\npregatire_interviu.ppt   \n"
},
{
	"uri": "https://danielanicolae.com/programare/access/",
	"title": "Access",
	"tags": [],
	"description": "",
	"content": "  Microsoft Access 2007.ppt\nInterogări (Query) Interogările reprezintă modalităţi de selecţie şi afişare a informaţie din unul sau mai multe surse (tabele sau alte interogări), formulate cu ajutorul unor condiţii logice. \nTipuri de interogări În funcţie de modul de definire şi rezultatele acţiunii, interogarile pot fi clasificate astfel:\ninterogări simple sau de selecţie (folosind condiţii logice);interogări pentru actualizare - delete query, update query şi append query;interogări încrucişate sau bidimensionale.Rezultatul interogării este un nou set de date, numit set dinamic (engl: Dynaset). Setul dinamic (rezultalul interogării) conţine doar câmpurile specificate ale înregistrarilor din tabelele specificate care satisfac condiţiile specificate. Denumirea \u0026lsquo;\u0026quot;Set dinamic\u0026quot; este legată de faptul că orice modificări ale datelor din tabelele specificate în interogare implică modificări corespunzătoare ale rezultatului interogării (la o nouă executare a ei) şi invers, orice modificări în setul dinamic implică modificări în tabelele respective (cu condiţia respectării integrităţii datelor). Seturile de date dinamice nu se memorează; ele se formează din nou de fiecare dată când executăm o interogare. Dacă în tabelele bazei de date intervin modificări, rezultatele executării a două interogari identice pot fi diferite.\nCrearea unei interogări simple (de selecţie a înregistrărilor -Select Query) Pentru a defini o interogare de selecţie selectăm opţiunea Queries din fereastra Database, apoi butonul Create query in design view.\n\nCa efect, va apărea fereastra alăturată, din care selectăm consecutiv (în orice ordine) tabelele necesare şi pentru fiecare acţionăm butonul Add. După selectarea tabelelor / interogărilor acţionăm butonul Close.\n\nÎn situaţia în care, după ce au fost stabilite sursele care vor fi interogate, dorim să revenim asupra lor şi să le schimbăm, avem la dispoziţie opţiunile meniului Query, cu menţiunea că pentru a înlătura o sursă trebuie mai întâi să o selectăm şi apoi să alegem Remove:\n  sau dăm clic dreapta pe sursă şi alegem Remove:\n   Dacă tabelele au câmpuri comune (definite în procesul creării lor), Access stabileşte în mod automat legăturile respective. În continuare indicăm, în partea de jos a ferestrei, câmpurile din fiecare tabel (în ordinea dorită), care urmează a fi afişate sau pentru care se vor specifica condiţii de selecţie şi / sau de sortare. Includerea câmpurilor se face prin \u0026quot;tragerea\u0026quot; lor cu ajutorul mouse-ului din tabelele din caseta de sus în rândul Field al casetei de jos sau prin executarea unui dublu-clic pe denumirile respective. După aceasta, specificăm condiţiile selecţiei şi / sau ordinea sortării, în acest fel interogarea se consideră definită.\n\nÎn rândul Criteria din partea de jos a ferestrei specificăm condiţia selecţiei. Dacă dorim ca înregistrările să fie afişate într-o anumită ordine (crescătoare / alfabetică sau descrescătoare), pentru câmpurile respective specificăm opţiunile Ascending sau Descending în rândul Sort.\n\nInterogarea astfel definită poate fi executată imediat în scopul obţinerii rezultatului, sau salvată pentru a fi executată ulterior. În primul caz, actionăm butonul (Datasheet View) din bara cu instrumente sau opţiunea Datasheet View din meniul View, în al doilea caz executăm comanda Save din meniul File. La salvarea interogării indicăm numele ei, care nu trebuie să coincidă cu numele unor tabele sau ale unor interogări definite anterior.Interogări de acţiune: Delete Query, Update Query şi Append Query Interogari de excludere (ştergere) a unor înregistrări (Delete Query) Creăm interogarea în modul Design View: selectăm Query din fereastra Database şi alegem modul de proiectare Design View.Includem tabela pentru care se execută interogarea.Selectăm Delete Query din meniul Query. Ca rezultat, titlul ferestrei se schimbă în Delete Query, iar în partea de jos a ferestrei apare rândul Delete.Din lista câmpurilor tabelei, care apare afisată în partea de sus a ferestrei, selectăm câmpurile care vor fi afişate în interogaresau pentru care vor fi specificate condiţii de selecţie şi le \u0026quot;tragem\u0026quot; în celulele respective ale liniei Field din partea de jos. Ca rezultat, în celulele respective apare automat, pentru fiecare câmp, opţiunea Where (din engleza - Unde, ín care).Introducem în celulele liniei Criteria condiţiile selecţiei (condiţiile pe care trebuie să le îndeplinească înregistrările care vor fi şterse, în dreptul câmpului corespunzător).Pentru a obţine lista înregistrărilor care urmează a fi excluse (dar încă n-au fost excluse), vizualizăm interogarea în modul Datasheet View.Dacă rezultatele obţinute sunt cele dorite, revenim în modul Design View pentru a elimina realmente înregistrările, selectând comanda Run din meniul Query. Ca rezultat, pe ecran apare un mesaj de informare despre numărul total al inregistrarilor care urmează a fi eliminate. Dacă acţionăm butonul Yes, înregistrările vizate sunt eliminate definitiv. Pentru renunţare, acţionam butonul No.Salvăm interogarea.Exemplu:Pentru tabela următoare:Eliminarea persoanelor care au studii \u0026quot;Liceale\u0026quot;:\nInterogări de actualizare a înregistrărilor (Update Query) Se utilizează în cazul în care este necesară modificarea unui număr mare de înregistrari, respectând aceeaşi modalitate de modificare. Vom descrie în continuare modul de definire a unei interogări de actualizare.\nCreăm interogarea în modul Design View: selectăm Query din fereastra Database şi alegem modul de proiectare Design View.Includem tabela pentru care se execută interogarea.Selectăm Update Query din meniul Query. Ca rezultat, titlul ferestrei se modifică în Update Query, iar în partea de jos apare rândul Update To.Includem (prin tragere) în celulele rândului Field câmpurile care dorim să apară în interogare sau cele pentru care vom stabili criterii de actualizare.Pentru ca anumite câmpuri ale tabelei să fie afişate în interogarea de actualizare trebuie să introducem în rândul Update To numele câmpului cuprins între paranteze drepte, altfel acesta nu va fi afişat. De asemenea, putem completa automat un câmp calculat, care nu a fost completat iniţial în tabelă. De exemplu, dacă avem tabela Medii, care are câmpurile: Numele şi prenumele elevului, Media sem I, Media Sem II şi Media generală, iar câmpul Media generală nu a fost completat iniţial pentru nici o înregistrare, vom trece în dreptul câmpului Media generală de pe rândul Update: ([Media sem I]+[Media sem II])/2.\nIntroducem în rândul Criteria condiţia pe care trebuie să o îndeplinească înregistrările care vor fi modificate.Vizualizăm interogarea în modul Datasheet View pentru a vedea modificările care se vor face. Modificările propriu-zise vor fi operate numai la revenirea în modul Design View şi executarea comenzii Run din meniul Query. ín acest caz, pe ecran va apărea un mesaj despre numarul total al înregistrărilor care urmează a fi modificate. Acţionând butonul Yes, Access va efectua modificările. Pentru a renunţa la modificări, acţionăm butonul No .Observaţie: Interogarile de tip Update se execută, de regulă, o singură dată. ín cazul executării repetate a interogării, de exemplu aplicarea unei scumpiri de 2% la pretul unor produse, această majorare va fi realizată la fiecare execuţie a interogării.\nInterogări de adăugare a înregistrărilor (Append Query) Se utilizează în cazul în care este necesară adăugareavunui set de înregistrări dintr-o tabelă în altă tabelă. Aceasta va selecta datele care tebuie adăugate şi le va trimite în câmpurile tabelei destinaţie. Vom descrie în continuare modul de definire a unei interogări de adăugare.\nCreăm interogarea în modul Design View: selectăm Query din fereastra Database şi alegem modul de proiectare Design View.Includem tabela pentru care se execută interogarea.Includem (prin \u0026quot;tragere\u0026quot;) în celulele rândului Field câmpurile care dorim să apară în interogare sau cele pentru care vom stabili criterii de adăugare.Selectăm Append Query din meniul Query. Indicăm tabela destinaţie.\nCa rezultat, titlul ferestrei se modifică în Append Query, iar în partea de jos apare rândul Append To.Introducem în rândul Criteria condiţia pe care trebuie să o îndeplinească înregistrările care vor fi preluate.Precizăm pe linia Append To numele câmpului destinaţie (doar în cazul în care nu au acelaşi nume).Vizualizăm interogarea în modul Datasheet View pentru a vedea modificările care se vor face. Modificările propriu-zise vor fi operate numai la revenirea în modul Design View şi executarea comenzii Run din meniul Query.\nInterogari Access Performantele unui SGBD depind în mare masura de capacitatea extragerii rapide a diferitor informatii în forma dorita. În multe cazuri este necesar de a selecta date din mai multe tabele simultan. De exemplu, pentru a selecta cartile din domeniul informaticii editate în Franta dupa anul 2001, utilizam 3 tabele: CĂRŢI, ŢĂRI si TEMATICI. Pentru a formula conditii de selectie, în MS Access exista o clasa speciala de obiecte (alaturi de tabel )numite Interogari (engl. Queries).nime: Interogari - Cereri - Interpelari.Interogarile reprezinta modalitati de selectie si afisare a informatie din unu sau mai multe tabele, formulate cu ajutorul unor conditii logice.Tipuri de interogari\nÎn functie de modul de definire si rezultatele actiunii, interogarile pot fi clasificate astfel:\na) interogari de selectie (folosind conditii logice);\nb) interogari de sortare (indicînd cîmpul/cîmpurile si ordinea sortarii);\nc) interogari de excludere a unor înregistrari din BD (de exemplu,excluderea tuturor cititorilor care nu au împrumutat carti în ultimii 2 ani);\nd) interogari de modificare a unor înregistrari din BD (de exemplu,majorarea preturilor tuturor car\u0026amp;# 14114g616o 355;ilor cu 20%);\ne) interogari de obtinerea a unor informatii rezultante (în cîmpuri noi)în baza informatiei existente (de exemplu, obtinerea vîrstei cititorului prin scaderea anului de nastere din anul curent);\nf) interogari de obtinere a unor totaluri, medii etc.;\ng) interogari încrucisate.\nÎn toate cazurile, cu exceptia ultimelor doua, rezultatul interogarii este un nou set de date, numit set dinamic (engl: Dynaset). Setul dinamic (rezultalul interogarii) contine doar cîmpurile specificate ale înregistrarilor din tabelele specificate care satisfac conditiilor specificate. Denumirea \u0026lsquo;\u0026quot;Set dinamic\u0026quot; este legata de faptul ca orice modificari ale datelor din tabelele specificate în interogare implica modificari respective ale rezultatului interogarii (la o noua executare a ei). si invers, orice modificari în setul dinamic implica modificari în tabelele respective (cu conditia respectarii integritatii datelor). Seturile dinamice nu se memorizeaza; ele se formeaza din nou de fiecare data cînd executam o interogare. Dac în tabelele BD intervin modificari, rezultatele executarii a doua interogari identice pot fi diferite, în cele ce urmeaza vom descrie modalitatile de definire si executare a interogarilor nominalizate.\nInterogari de selectie a înregistrarilor(Select Query)Exemplu:1Pentru a defini o interogare de selectie (de exemplu, afisarea emisiunilor cu desene animate), actionam fila Queries din fereastra Database (fig. 10), apoi butonul New.\nfig.10 Fereastra cu clasele de obiecte Access\nÎn continuare indicam unul din cele 5 moduri de creare a interogarilor (în cazul nostru Design View)\nDin caseta care apare (fig. 11) selectam consecutiv (în orice ordine) tabelele necesare (în cazul nostru,Emisiuni,Genuri,Canale TV) si pentru fiecare actionam butonul Add.\n\nfig.11 Selectarea tabelelor pentru definirea interogarii\nDupa selectarea tabelelor actionam butonul Close. Daca tabelele au cîmpuri comune (definite în procesul crearii lor), Access stabileste în mod automat legaturile respective (fig. 12). În continuare indicam, în partea de jos a ferestrei, cîmpurile din fiecare tabel (în ordinea dorita) care urmeaza a fi afisate sau pentru care se vor specifica conditii de selectie si/sau de sortare. Includerea cîmpurilor se face prin \u0026quot;tragerea\u0026quot; lor cu ajutorul mouse-ului din tabelele din caseta de sus în rîndul Field al casetei de jos sau prin executarea unui dublu-clic pe denumirile respective. Dupa aceasta specificam conditiile selectiei si/sauordinea sortarii, în acest fel interogarea se considera definita (fig. 12).\n\nfig12.Specificarea conditiilor de selectie\nÎn rîndul Criteria din partea de jos a ferestrei specificam conditia selectiei Des* pentru cîmpul DenGen al tabelului Genuri. Daca dorim ca înregistrarile sa fie afisate într-o anumita ordine (crescatoare/alfabetica sau descrescatoare) pentru cîmpul respective specificam optiunile Ascending sau Descending în rîndul sort. Daca indicam Ascending pentru cîmpul DenEmisiunii al tabelului emisiuni denumirile emisiunilor vor fi afisate în ordenea alfabetica.\nInterogarea astfel definita poate fi executata imediat în scopul obtinerii rezultatului (fig. 13), sau salvata pentru a fi executata ulterior. În primul caz actionam butonul (Datasheet View) din bara cu instrumente în aldoile caz executam comanda Save din meniul File. La salvarea interogarii indicam numele ei, care nu trebuie sa coincida cu numele unor tabele sau ale unor interogari definite anterior. Setul dinamic (rezultatele interogarii) contine cîmpurile marcate cu simbolul în rîndul Show al ferestrei. Celelalte cîmpuri chiar daca sunt incluse în interogare, nu se afiseaza.\nfig.13 Rezultatele interogarii\nExemplu 2. Lista emisiunilor cu durata mai mica de 30 de minute.\nPentru afisarea emisiunilor cu durata mai mica de 30 minute actionam fila Queries din fereastra Database , apoi butonul New. În continuare indicam unul din cele 5 moduri de creare a interogarilor, în cazul nostru Design View (fig.14).\nfig.14\nDin caseta care apare (fig.15) selectam tabelul Emisiuni,Canale TV si Genuri si actionam butonul Add.\nfig.15\nDupa selectarea tabelului actionam butonul Close. Apoi executam dublu clic pe denumirile câmpurilor si vor trece în rîndul Field din caseta de jos (fig.16).\nfig.16\nDupa aceasta specificam conditiile selectiei. În rîndul Criteria scrim conditia \u0026lt;30 pentru câmpul Durata Emisiunii al tabelului Emisiuni si ne va afisa lista emisiunilor cu durata mai mica de 30 minute.\nfig.17. Rezultatul interogarii\nExempul 3: Lista emisiunilor stiri\nPentru afisarea emisiunilor stiri actionam fila Queries din fereastra Database , apoi butonul New. În continuare indicam unul din cele 5 moduri de creare a interogarilor, în cazul nostru Design View (fig.14).\nDin caseta care apare (fig.15) selectam tabelul Emisiuni , Genuri actionam butonul Add .Dupa selectarea tabelului actionam butonul Close.\nApoi executam dublu clic pe denumirile câmpurilor si vor trece în rîndul Field din caseta de jos (fig.18).\nfig.18\nDupa aceasta specificam conditiile selectiei. În rîndul Criteria scrim conditia \u0026quot;stiri\u0026quot; pentru câmpul DenGen al tabelului Genuri si ne va afisa lista emisiunilor stiri.\nfig.19. Rezultatul interogarii\nExemplul 4: Lista emisiunilor în limba rusa\nFie ca dorim sa afisam lista emisiunilor în limba rusa. Pentru aceasta executam urmatorii pasi:\nDefinim o interogare în care includem tabelele Emisiuni, Limbi, Canale TV din care selectam câmpurile DenEmisiunii, DenCanal, DenLimba (fig.20)\nfig.20\nDupa aceasta specificam criteriul de selectie în rîndul Criteria pentru câmpul DenLimba din tabelul Limbi si ne va afisa lista emisiunilor în limba rusa.\nfig.21\nInterogari de sortare a înregistrarilor\nDupa ce am definit conditiile de selectie, putem stabili conditii de sortare pentru unul sau mai multe câmpuri.\nExemplu 1: Pentru afisarea emisiunilor în ordine alfabetica executam un clic în rîndul Sort al casetei (fig.22) în dreptul câmpului DenEmisiuni si din lista derulanta alegem optiunea Ascending.\nfig.22\nPentru a afisa rezultatul interogarii (fig.23), actionam butonul (Datasheet View) din bara cu instrumente.\nfig.23\nSortarea datelor poate fi facuta si fara a specifica conditii de selectie. În acest caz se vor afisa toate înregistrarile, dar ordinea lor va corespunde conditiilor stabilite în rîndul Sort pentru câmpurile respective.\nExemplu 2: Lista emisiunilor în ordinea duratei lor.\nPentru afisarea emisiunilor în ordine duratei lor executam un clic în rîndul Sort al casetei (fig.24) în dreptul câmpului Durata emisiunii si din lista derulanta alegem optiunea Ascending.\nfig.24\nPentru a afisa rezultatul interogarii (fig.25), actionam butonul (Datasheet View) din bara cu instrumente.\nfig.25\nInterogari de actualizare a înregistrarilor (Update Query)\nÎn cazul cînd este necesar de a modifica un numar mare de înregistrari conform unuia si aceluiasi algoritm, putem defini o interogare de modificare (Update Query)\nVom descrie în continuare modul de definire a unei interogari pentru care stirile se maresc cu 5 minute.\n1. Definim interogarea în modul descris în p.5.1.\n2. Includem tabelul Emisiuni si Genuri.\n3. Selectam Update din meniul Query sau actionam butonul din bara de instrumente.Ca rezultat titlul ferestrei se modifica în Update Query, iar în partea de jos apare rîndul Update To (fig.26).\nfig.26\n4. Includem (prin \u0026quot;tragere\u0026quot;) în celulele rîndului Field câmpurile DenEmisiunii, DenGen, Durata emisiunii.\n5. Introducem în rîndul Update To pentru câmpul DenEmisiunii expresia [DenEmisiunii], DenGen expresia [DenGen], Durata emisiunii expresia [Durata emisiunii]+5\n6. Introducem în rîndul Criteria pentru câmpul DenGen conditia Stiri.\n7. Actionam butonul din bara cu instrumente, pentru a obtine valorile curente ale câmpului Durata emisiunii care urmeaza a fi modificate (fig.27).\nfig.27\nModificarile propriu-zise vor fi operate numai dupa trecerea în regimul Design View si actionarea butonului din bara cu instrumente sau executarea comenzii Run din meniul Query. În acest caz pe ecran va aparea un mesaj despre numarul total al înregistrarilor care urmeaza a fi modificate. Actionînd butonul Yes , Access va efectua modificarile (fig.28). Pentru a renunta la modificari, actionam butonul No .\n\nfig.28\nRemarca:Interogarile de tip Update se executa de regula o singura data. În cazul executarii repetate a interogarii definite în exemplul de mai sus, vom obtine de fiecare data marirea emisiunilor stiri cu 5 minute.\nInterogari de excludere a înregistrarilor (Delete Query)\nFie, de exemplu, ca dorim sa excludem din tabelul Emisiuni toate emisiunile între ora 1000 -1200. Pentru aceasta, executam urmatoarele actiuni:\n1. Definim interogarea în modul descris în p 5.1.\n2. Includem tabelul Emisiuni.\n3. Selectam Delete Query din meniul Query sau actionam butonul\n(daca este afisat) din bara cu instrumente. Ca rezultat, titlul ferestrei se\nschimaг în Delete Query iar în partea de jos a ferestrei apare rîndul Delete.\n4. Din lista cîmpurilor tabelului Emisiuni, afisata în partea de sus a ferestrei (fig. 8.12), selectam câmpurile care vor fi afisate sau pentru care vor fi specificate conditii de selectie DenEmisiunii si Timpul începerii si le \u0026quot;tragem\u0026quot; în celulele respective ale rîndului Field din partea de jos. Ca rezultat, în celulele respective pentru fiecare câmp apare optiunea\nWhere (din engleza - Unde, In care).\n5. Introducem în celulele rîndului Criteria conditiile selectiei. În cazul nostru pentru cîmpul Timpul începerii scriem conditia Between 1000 And 1200.\nfig.29\n6. Pentru a obtine lista înregistrarilor care urmeaza a fi excluse (dar înca n-au fost excluse), actionam butonul (Datasheet View) din bara cuinstrumente. Ca rezultat, obtinem fereastra, reprezentata în figura 8.13.\nfig.30\n7. Daca rezultatele obtinute în p.6 sunt cele dorite, revenind la regimulDesign View, putem elimina realmente înregistrarile, executînd comanda Run din meniul Query sau actionînd butonul (Run) din bara cu instrumente. Ca rezultat, pe ecran apare un mesaj despre numarul total al înregistrarilor care urmeaza a fi eliminate. Daca actionam butonul Yes, înregistrarile vizate sunt eliminate definitiv. Pentru renuntare, actionam butonul No.\n8. Salvam interogarea, executînd comanda Save As din meniul File si\nindicînd numele interoga\nInterogari de grupare si totalizare a înregistrarilor\nÎn multe cazuri apare necesitatea de a obtine valori rezumative referitoare la toate înregistrarile din tabel sau pentru o submultime a lor. De exemplu, ar putea sa ne intereseze cîte emisiuni de fiecare gen sunt. În acest scop în Access pot fi definite interogari în care sunt specificate conditii de grupare si totalizare.\nPentru obtinerea valorilor rezumative, sunt prevazute urmatoarele functii:\n-Sum, pentru calcularea sumei valorilor cîmpului;\n-Avg, pentru calcularea mediei valorilor cîmpului;\n-Min, pentru gasirea valorii minime;\n-Max, pentru gasirea valorii maxime;\n-Count, calculeaza numarul de valori ale cîmpului (excluzînd cele vide);\n-StDev, pentru calcularea abatem standard;\n-Var, pentru calcularea dispersiei.\nValorile rezumative pot fi obtinute atît pentru toate înregistrarile din tabel cît si pentru grupuri de înregistrari.\nFie ca dorim sa obtinem informatii despre cîte emisiuni de fiecare gen sunt. Pentru aceasta executam urmatoarele actiuni:\n1. Definim o interogare în care includem tabelele Emisiuni si Genuri din care selectam cîmpurile DenGen si DenEmisiunii (fig)\nfig.31\n2. Selectam optiunea Totals din meniul View; ca rezultat în caseta de jos apare rîndul Total, iar în celulele respective ale cîmpurilor selectate optiunea Group By\n3. Din lista derulanta a cîmpului DenEmisiunii (rîndul Total) selectam optiunea Count.4. Actionam butonul pentru a obtine valorile cautate (fig)\nfig.32\nInterogari încrucisate (Crosstab Query)\nIn multe cazuri rezultatele unei interogari sunt greu de perceput din cauza volumului mare de informatii selectate. In figura sunt prezentate datele despre cîte emisiuni de fiecare gen sunt, obtinute cu ajutorul unei interogari de grupare si totalizare.\nfig\nAccess permite gruparea si reprezentarea datelor într-o forma compacta, forma care se aseamana cu un tabel electronic.În acest scop se definesc interogari speciale, numite interogari încrucisate (Crosstab Query).\nPentru a defini o interogare încrucisata procedam initial ca în cazul unei interogari de selectie obisnuita, adica selectam tabelele Emisiuni, Canale TV, Genuri, din care selectam câmpurile DenGen, DenCanal, DenEmisiunii (fig)\nfig\nÎn continuare parcurgem urmatorii pasi:\n1. Selectam optiunea Crosstab din meniul Query. Ca rezultat, titlul ferestrei\nse schimba în Crosstab Query, iar în partea de jos apare rîndul Crosstab.\n2. Definim câmpul DenGen, valorile caruia vor servi în calitate de denumiri ale rîndurilor tabelului. Pentru aceasta actionam butonul cu sageata din rîndulCrosstab pentru câmpul DenGen si din lista derulanta care apare selectam optiunea Row Heading.\n3. In mod analogic definim câmpul DenCanal, valorile caruia vor servi în calitate de denumiri ale coloanelor tabelului . Pentru aceasta actionam butonul cu sageata din rîndul Crosstab pentru câmpul DenCanal si din lista derulanta care apare selectam optiunea Column Heading.\n4. În rîndul Total înlocuim optiunea Group By din câmpul DenEmisiunii prin\noperatorul Count.\n5. Pentru câmpul DenEmisiunii în rîndul Crosstab stabilim optiunea Value pe\ncare o selectam din lista derulanta prin analogie cu actiunile descrise mai sus.\n6. Actionam butonul pentru vizualizarea rezultatelor (fig)\n\n   \n"
},
{
	"uri": "https://danielanicolae.com/programare/algoritmi/",
	"title": "Algoritmi",
	"tags": [],
	"description": "",
	"content": "  INFORMATICA\nInformatica este stiinta care se ocupa cu studiul reprezentarii si organizarii informatiei precum si cu studiul algotitmilor de prelucrare a informatiei cu ajutorul unui calculator.\nALGORITM\nUn algoritm reprezinta o metoda de rezolvare a problemelor de un anumit tip.A rezolva o problema inseamna a obtine ,pentru anumite date de intrare ,rezultatul problemei (date de iesire ).Algoritmul este constiuit dintr-o succesiune de operatii care descriu, pas cu pas, modul de obtinere a datelor de iesire, plecand de la datele de intrare .\nExemplu :\nPresupunand ca dispunem de un aragaz ,o tigaie ,2 oua ,sare si 200 ml ulei ,sa pregatim ochiuri .\n“Date,, de intrare :oua ,ulei ,sare .\n“Date ,,de iesire :ochiuri .\nPas 1: Se pune tigaia pe foc . \nPas 2: Se toarna uleiul in tigaie .\nPas 3: Asteptam pana cand se incinge uleiul.\nPas 4: Spargem cu indemanare ouale se rumenesc.\nPas 5: Asteptam pana cand ouale se rumenesc .\nPas 6: Daca nu tinem regim ,adaugam sare .\nProprietati caracteristice ale algoritmilor \n1.Claritatea–la fiecare moment ,operatia care urmeaza a fi executata este unic determinata ,definita si realizabila .\n2.Generalitatea(universalitatea )-o secventa de pasi reprezinta un algoritm de rezolvare a unei probleme daca obtine date iesire (rezultate ) pentru orice date de intraren specifice problemei .\n3.Finititudinea–rezultatele problemei se obtin dupa o secventa de pasi .\nUn algoritm este constituit dintr-o succesiune clara de operatii realizabile,\ncare au ca scop obtinerea intr-un timp finit a rezultatelor unei probleme,\npentru orice set de date de intrare .\nDATE\nOrice algoritm lucreaza cu date :date de intrare (datele pe care trebuie sa le primeasca un algoritm din exterior ),date de iesire (datele pe care trebuie sa le furnizeze aloritmul in exterior ),precum si date de manevra (date temporale ,necesare algoritmului pentru a obtine datele de iesire pe baza datelor de intrare ).\nDatele cu care lucreaza algoritmii pot fi clasificate din mai multe puncte de vedere.O prima clasificare a datelor ,in functie de posibilitatea de a-si modifica valoarea ,este:\n1.Constante –date care nu isi modifica valoarea .\n2.Variabile –date care isi modifica valoarea .\nIn functie de valoarea lor,datele pot fi clasificate astfel:\na.Date numerice –au ca valori numere (naturale ,intregi sau reale );\nb.Date alfabetice –au ca valori caractere sau siruri de caractere ; c.Date logice –au ca valori adevarat sau fals.\nExpresii\nO expresie este constituita dintr-o succesiune de operanzi ,conectati prin operatori.Un operand poate fi o constanta ,o variabila ,sau o expresie incadrata intre paranteze rotunde .Operatorii desemneaza operatiile care se executa asupra operanzilor.Operatorii care pot fi utilizati intr-o expresie depind de tipul operanzilor .\nVom prezenta trei categorii de operatori.\nOperatori aritmetici definesc o operatie aritmetica si pot fi clasificati astfel:\n1.operatori aritmetici multiplicative :*(inmultire ), /(impartire),%(restul impartirii intregi).\n2.operatori aritmetici aditivi :+(adunare)si –(scadere ).\nOperatori relationali\nOpertorii relationali descriu relatia de ordine sau de egalitate dintre cei doi operanzi:\u0026lt;(mai mic),\u0026gt;(mai mare),\u0026lt;=(mai mic sau egal).\u0026gt;=”(mai mare sau egal),=(egal),!=(diferit ).\nOperatori logici \nOperatori logici definesc o operatie logica :negatia logica - !;conjunctie logica – si ;disjunctie logica - sau .Efectul acestor operatori este cel usual ,invatat la logica ,matematica .Il reamintim in tabelul urmator:\n X\n Y\n !X\n X sau Y\n X si Y\n   Fals \n Fals \n Adevarat\n Fals \n Fals \n   Fals \n Adevarat\n Adevarat\n Adevarat\n Fals \n   Adevarat \nAdevarat\n Fals \nAdevarat\n Fals\nFals \n Adevarat\nAdevarat\n Fals \nAdevarat\n   \nOperatori logici se pot aplica operanzilor logici .Valoarea unui expresii logice este de tip logic .\nReprezentarea algoritmilor\nI.Principiile programarii structurate\nProgramarea structurata a aparut in anii 70 datorita cresterii complexitatii aplicatiilor , aducand o serie de principii si tehnici inovative . Modularizarea este una dintre ele , permitand impartirea problemei in subprobleme de dimensiuni mai mici si complexitate mai redusa.Problemele erau rezolvate de echipe de programatori si rezultatele erau combinate in scopul rezolvarii problemei initiale.\nO alta tehnica importanta a fost cea a structurarii datelor si prelucrarilor.Structurarea datelor permitea gruparea datelor in anumite zone de program , dar si descrierea si utilizarea unor structuri de date proprii.Structurarea prelucrarilor se poate realiza prin utilizarea modulelor si a subprogramelor .Un principiu important presupunea ca orice program se poate scrie prin secvente liniare , alternative si repetitive.\nII. Descrierea algoritmilor\nUn algoritm de rezolvare presupune stabilirea pasilor necesari. Pasii necesari pot fi descrisi intr-un limbaj de programare , insa nu toata lumea cunoaste acel program si niciun program nu s-a impus ca fiind singurul utilizat de programatori . Din acest motiv s-au impus niste metode generale de descriere a algoritmilor independente de limbajul de programare . Programele se scriu pe baza acestor descrieri . Metodele cele mai importante sunt :\n∙ pseudocodul\n∙ schema logica \nPSEUDOCODULreprezinta un set restrans de cuvinte in romana sau engleza asociate unor operanti.Astfel , cuvintele utilizate sunt : intreg , real , citeste , scrie , daca , atunci , altfel , sfarsit daca , pentru , cat timp , sfarsit cat timp , executa cat timp .\nExemplu : Cititi doua variabile intregi . Calculati suma lor si afisati rezultatul. \nintreg a , b , c\nciteste a , b\nc= a + b\nscrie c\nSCHEMA LOGICAeste reprezentarea grafica a unor prelucrari. Aceasta reprezinta un set de simboluri grafice.\nSTRUCTURA SECVENTIALA(LINIARĂ)\nPresupune executarea unei prelucrari in ordinea precizata . ( ele nu se executa conditional sau repetitiv ). Exista cateva tipuri , printre care :\n1.) Declararea variabilelor se face cu sintaxa ,, tip data variabila ’’. Definirea variabilei pune in legatura numele variabilei cu tipul sau .\n2.)Citirea variabilei reprezinta operatia prin care continutul unei variabile e incarcat de la tastatura.\n3.)Atribuirea este operatia prin care o valoare e asociata unei variabile.\n4.)Afisarea se realizeaza cu sintaxa scrie exp 1 , \u0026hellip; , exp n\n5.)Instructiunea compusa reprezinta un set de prelucrari cuprinse intre acolade .\n{ p1\n.\n.\n} pn \nSTRUCTURA ALTERNATIVA\nSCOP : permite efectuarea unei unui set de operații in functie de valoarea unei conditii.\nAre două forme:\n1.daca_conditie / expresie\ninstr.\nsfarsit_daca \nMECANISM DE FUNCTIONARE : se evalueaza conditia sau expresia la o valoare logica. Daca e adevarata se realizeaza instr. , daca nu , nu se executa nimic.\n2. daca_cond atunci\ninstr1\naltfel\ninstr2\nsfarsit_daca \nMecanism de functionare : se evalueaza conditia la o valoare logica.Daca este adevarat se executa instr1 , daca nu , se executa instr2.\nSELECTIA MULTIPLA\nEste o structura derivata. Ea poate fi inlocuita prin struturi decizionale , deoarece este implementata de instructiuni in limbaje de programare. Ea poate fi prezentata in schema logica si pseudocod :\ncase_exp\nv1 , p1\n\u0026hellip;\u0026hellip;\u0026hellip;..\nvn , pn\nend_case\nMecnism de functionare : se evalueaza expresia . Daca valoarea obtinuta = V1 , atunci se executa P1 si se iese din instructiune . Daca nu , se compara valoarea cu V2.Daca sunt egale se executa P2 . Daca nu , valoarea se compara cu Vn , daca e egala se executa Pn si se iese din instructiune.\nSTRUCTURA “PENTRU”\nSCOP : permite executarea unei prelucrari de un numar cunoscut de ori . Este o structura cu text initial si numar cunoscut de iteratii.\nPrin text initial se intelege faptul ca se efectueaza intai testarea conditiei si apoi se efectueaza prelucrarea.\npentru_K=Vc , Vf executa\ninstructiune\nsfarsit_pentru \nMECANISM DE FUNCTIONARE : se initializeaza K ( contorul ) cu o valoare initiala . Se evalueaza contorul K\u0026lt;_Vf . Daca e adevarat , se realizeaza prelucrarea si creste contorul initial cu o unitate , daca nu , se iese din structura.\nObs:Se efectueaza in mod repetat o singura prelucrare , mai multe prelucrari fiind incluse-ntr-o structura bloc.\nAplicatii:\n1) Calculati suma primelor n numere naturale .\nRezolvare : \nintreg n, i , S\nciteste n\nS=0\nPentru i=1 , n executa\nS= s + i\nSfarsit pentru\nScrie S.\nSimulare numerica:\nn=3 , S=0\nP1 i=1 , 1≤3 (a) , S=0+1=1 , i=1+1=2\nP2 i=2 , 2≤3 (a) , S=1+2=3 , i=2+1=3\nP3 i=3 , 3≤3 (a) , S=3+3=6 , i=3+1=4\nP4 i=4 , 4≤3 (f) , scrie 6 .\n2.)Se citesc n valori . Calculati produsul valorilor pozitive si suma valorilor negative .\nRezolvare : \nintreg n , i , x , S , P\nciteste n\nS=0 \nP=1\nPentru i=1 , n executa\nCiteste x \ndaca_x≥0 , atunci P=P*x\naltfel S=S+x\nsfarsit daca\nsfarsit pentru\nscrie S , P\nSimulare numerica :\nn=3 , P=1 , x=2 , -1 , 3\nP1 i=1 , 1\u0026lt;_3 (a) , x=2 , 2\u0026gt;0 (a) , P=1*2=2 , i=1+1=2\nP2 i=2 , 2\u0026lt;_3 (a) , x=-1 , -1\u0026gt;0 (f) , S=-1 , i=1+2=3\nP3 i=3 , 3\u0026lt;_3 (a) , x=3 , 3\u0026gt;0 (a) , P=2*3=6 , i=3+1=4\nP4 i=4 , 4\u0026lt;3(f) scrie -1 , 6\nSTRUCTURA “CAT TIMP”\nSCOP : permite executarea unei prelucrari cat timp o conditie e indeplinita . Este o structura cu test initial si numar necunoscut de iteratii.( test initial=se efectueaza mai intai testul conditiei si apoi prelucrarea , numar necunoscut de iteratii= programatorul nu cunoaste la momentul scrierii programului de cate ori se repeta prelucrarea respectiva )\nCat_timp cond/expresie executa\ninstructiune\nSfarsit cat_timp \nMECANISM DE FUNCTIONARE : se evalueaza conditia la o valoare logica. Daca e adevarata , se executa prelucrarea P si se revine la testul conditiei , daca nu , se iese din structura.\nOBS : \n1-Dacă expresia este falsa (egala cu zero) din primul pas, instrucțiunea nu se execută niciodată.\n2-Este obligatorie modificarea condiției/expresiei , în caz contrar ciclul este infinit.\nAlpicatii :\n1.)Calculati suma primelor n numere naturale folosind structura cat timp.\nRezolvare :\nintreg n , i , S\nciteste n\nS=0\ni=1\ncat_timp i≤n executa\nS=S + i\ni=i+1\nsfarsit_cat_timp\nscrie S\nSimulare numerica:\nPo n=3 , S=0 , i=1\nP1 i=1 , 1\u0026lt;_3 (a) , S=0+1=1 , i=1+1=2 \nP2 i=2 , 2\u0026lt;_3 (a) , S=1+2=3 , i=1+2=3\nP3 i=3 , 3\u0026lt;_3 (a) , S=3+3=6 , i=3+1=4\nP4 i=4 , 4\u0026lt;_3 (f) , scrie 6.\n2.)Calculati produsul a n valori citite de la tastatura.\nRezolvare :\nintreg n , i , P , x\nciteste n\nP=1\ni=1\ncat_timp i\u0026lt;_n executa\nciteste x\nP=P*x\ni=i+1\nsfarsit cat timp\nSimulare numerica:\nPo n=3 , x=2,4,6 , P=1\nP1 i=1 , 1\u0026lt;_3 (a) , x=2 , P=1*2=2 , i=1+1=2\nP2 i=2 , 2\u0026lt;_3 (a) , x=4 , P=2*4=8 , i=1+2=3\nP3 i=3 , 3\u0026lt;_3 (a) , x=6 , P=6*8=48 , i=1+3=4\nP4 i=4 , 4\u0026lt;_3 (f) , scrie 48.\nRETINETI!\n∙ Pentru a calcula inversul unui numar trebuie sa folosim formula :\n NINV=NINV*10+c\n   unde c=n%10 , iar n=n/10\n∙ Pentru a demonstra daca un numar e palindrom trebuie ca acesta sa fie egal cu inversul sau.\nEx : 123 nu e palindrom\n121 e palindrom. \n3.) Calculati suma cifrelor unui numar .\nEx : n=123\nSuma cifrelor=1+2+3=6\nPseudocod:\nIntreg n,s,c\nCiteste n\nS=0\nCat timp n\u0026gt;0 executa\nC=n%10\nS=s+c\nN=n/10\nSfarsit cat timp\nScrie s\nSimulare numerica:\nP0:n=123,s=0\nP1:123\u0026gt;0 A, c=123?%10=3,s=0+3,n=123\u0026frasl;10=12\nP2:n=12\u0026gt;0 A,c=12%10=2,s=3+2=5,n=1\u0026frasl;10=1\nP3:n=1\u0026gt;0 A,c=1%10=1,s=5+1=6,n=1\u0026frasl;10=0\nP4:n=0\u0026gt;0 F,scrie s=6\n4.)Calculati produsul cifrelor unui numar.\nPseudocod:\nIntreg n,p ,c\nCiteste n\nP=1\nCat timp n\u0026gt;o executa\nC=n%10\nP=p*c\nN=n/10\nSfarsit cat timp\nscrie p\nSimulare numerica:\nP0:n=123,p=1\nP1:n=123\u0026gt;0 A,c=123%10=3, p=1*3=3,n=123\u0026frasl;10=12\nP2:n=12\u0026gt;0A, c=12%10=2,p=3*2=6,n=12\u0026frasl;10=1\nP3: n=1\u0026gt;0 A,c=1%10=1, p=6*1=6,n=1\u0026frasl;10=0\nP4:n=0\u0026gt;0 F,scrie p=6\nSTRUCTURA EXECUTĂ..CAT TIMP\nSCOP : permite executarea unei prelucrari cat timp o conditie e indeplinita . Este o structura cu test final si numar necunoscut de iteratii.( test final=se efectueaza mai intai prelucrarea și apoi testul conditiei , numar necunoscut de iteratii= programatorul nu cunoaste la momentul scrierii programului de cate ori se repeta prelucrarea respectiva )\nexecuta\ninstructiune\nCat_timp cond/expresie\nMECANISM DE FUNCTIONARE : se execută instrucțiunea, se evalueaza conditia la o valoare logica. Daca e adevarata , se executa din nou intrucțiunea si se revine la testul conditiei , daca nu , se iese din structura.\nOBS : \n1- Instrucțiunea se execută cel puțin o dată indifereant de valoarea condiției\n2-Este obligatorie modificarea condiției/expresiei , în caz contrar ciclul este infinit.   \n"
},
{
	"uri": "https://danielanicolae.com/programare/aplicatii_complexe/",
	"title": "Aplicatii Complexe",
	"tags": [],
	"description": "",
	"content": "  APLICATII COMPLEXE\n1.Scrieti un program C/C++ care citeste de la tastatura doua siruri de caractere formate din litere mici. Sa se creeze fisierul BAC.TXT in care sa scrie unul din cele doua siruri care se dovedeste a fi o subsecventa a celuilalt sir. Daca cele doua siruri nu au aceasta proprietate atunci in fisierul BAC.TXT se va scrie textul “FARA SOLUTIE”.\nExemplu:\nSe citesc sirurile: Se afiseaza in BAC.TXT\nCalculator lat\nlat\n2.Scrieti un program C/C++ care citeste de la tastatura un numar natural n (2\u0026lt;n\u0026lt;21) si apoi n linii cu cate n numere intregi de cel mult 7 cifre ce formeaza un tablou bidimensional a.\nSa se afiseze pe ecran diferenta dintre suma elementelor de pe diagonala principala si suma elementelor de pe diagonala secundara a matricei a.\n3.Fisierele text X.TXT si Y.TXT contin fiecare numele a 7 persoane, câte un nume pe fiecare linie , fiecare nume având cel mult 15 litere. Stiind ca în fiecare fisier numele sunt memorate în ordine alfabetica, scrieti un program C/C++ care sa citeasca din cele doua fisiere si sa afiseze pe ecran toate numele din cele doua fisiere în ordine alfabetica, separate printr-un spatiu.\nExemplu :\nDaca fisierul X.TXT are continutul :\nAna\nDana\nDaniel\nEne\nMara\nNae\nPaul\niar fisierul Y.TXT are continutul:\nAngie\nCora\nDora\nHoria\nOana\nPaul\nTibi\nSe va afisa pe ecran :\nAna Angie Cora Dana Daniel Dora Ene Horia Mara Nae Oana Paul Paul Tibi\n4. Scrieti programul C/C++ care scrie de la tastatura un numar natural n (n\u0026lt;100) si un sir cu n numere intregi din intervalul [100 ;999] ; programul construieste un sir de numere rezultat prin inlocuirea fiecarui numar din sirul citit cu numarul obtinut prin interschimbarea cifrei unitatilor cu cifra sutelor. umerele din noul sir se vor afisa pe ecran separate printr-un singur spatiu.\nDe exemplu , pentru n=3 si sirul 123 , 904 , 500 , se afiseaza 321 , 409 , 5.\n5.Doua tablouri unidimensionale a si b , cu elementele a1 , a2 , … , an , respctiv b1 , b2 , … bn sunt in relatia a\u0026lt;=b daca : a1\u0026lt;=b1 , a2\u0026lt;=b2 , … , an\u0026lt;=bn. Scrieti program in limbajul C/C++ care citeste doua tablouri unidimensionale a si b cu acelasi numar de elemente de tip intreg si verifica daca a\u0026lt;=b sau b\u0026lt;=a afisand un mesaj adecvat.\n6.Scrieti subprogramul sortare care primeste prin intermediul parametrului a un tablou unidimensional de numere reale cu 1000 de componente si prin intermediul parametrilor i si j doua numere intregi , 1\u0026lt;=i\u0026lt;j\u0026lt;=1000. Subprogramul realizeaza ordonarea crescatoare a elementelor ai , ai+1 , … , aj.\n7. Scrieti programul C/C++ care citeste de la tastatura elementele unui vector x cu 1000 de numere reale si care ordoneaza crescator termenii sirului. Programul va afisa pe ecran noile valori ale vectorului x separate intre ele prin spatiu.\n8. Intr-un sistem de coordonate carteziene se considera punctele A(x1,y1) si B(x2,y2), unde coordonatele intregi x1 , y1 , x2 , y2 sunt , in aceasta ordine , urmatorii termini consecutive ai sirului Fibonacci : fn , fn+1 , fn+2 , fn+3 (n natural).Scrieti un program C/C++ care citeste de la tastatura un numar natural n (1\u0026lt;=n\u0026lt;=20) , determina si afiseaza pe ecran cele doua puncte A si B astfel determinate.\n9.Într-o lista simplu înlantuita alocata dinamic, fiecare element retine în câmpul info un numar natural cu cel mult noua cifre si in câmpul adru adresa elementului urmator din lista. Scrieti subprogramul divizor, care prin parametrul p primeste adresa primului element al listei descrise mai sus, prin parametrul x primeste un numar natural cu cel mult noua cifre si care afiseaza pe ecran, câte unul pe linie numerele din lista care au exact un divizor comun cu x. Daca în lista nu exista un astfel de element atunci se va afisa mesajul “problema nu are solutie”.\n10.Fisierele text f1.txt si f2.txt contin , fiecare , elementele a cate unui sir de numere reale a , respective b.Fisierele contin numere distincte scrise pe o linie si separate printr-un singur spatiu. Scrieti un program in limbajul C/C++ care citeste cele 2 siruri de numere din fisierele f1.txt si f2.txt si care scrie in fisierul f3.txt toate elementele comune sirurilor a si b , pe o linie si separate printr-un spatiu.\nExemplu : Daca continutul fisierelor f1.txt si f2.txt este : 10.3, 2.05, 5, 7.12, respectiv 67 , 7.12 , 5 , 3 , 7.33 , 9 , atunci f3.txt va contine : 7.12, 5. (10p.)\n11. Scrieti un program in limbajul C/C++ care afiseaza toate numerele naturale formate din cifre identice , mai mari decat 10 si mai mici decat o valoare data n, n\u0026lt;=2.000.000.000.\nDe exemplu pentru n=195 , se afiseaza : 11 , 22 , 33 , 44 , 55 , 66 , 77 , 88 , 99 , 111.\n12. Prin asocierea fiecarei litere mici din alfabetul englez cu un numar egal cu pozitia cifrei in alfabet, se poate codifica orice secventa de litere mici cu o secventa de numere. Scrieti un program C/C++ care citeste din fisierul text cod.txt un numar n (0\u0026lt;n\u0026lt;30000) si, de pe randul urmator , o secventa de n litere mici. Programul va codifica secventa de caractere citita si va scrie pe ecran numerele asociate, separate prin spatii.\nExemplu : pentru fisierul cod.txt : 7\nbacinfo\nse vor afisa pe ecran , in ordine , numerele :\n2 1 3 9 14 6 15\n13. Scrieti un program C/C++ care citeste de la tastatura trei numere naturale x, y si k, (1\u0026lt;x\u0026lt;y\u0026lt;2000000, k\u0026lt;1000) si afiseaza pe ecran k numere prime din intervalul [x, y]. Daca nu exista k numere prime în intervalul [x,y] se vor afisa toate numerele prime gasite iar pe linia urmatoare se va afisa mesajul “s-au gasit mai putine numere prime: ” urmat de numarul acestora. De exemplu, pentru x=3, y=12 si k=5 se vor afisa pe ecran:\n3 5 7 11\ns-au gasit mai putine numere prime:4\n14. Scrieti un program C/C++ care citeste un numar natural nenul par, n, n\u0026lt;100 si apoi n numere naturale de cel mult 4 cifre fiecare si determina cea mai mare suma care poate fi obtinuta adunand numai o jumatate din toate numerele naturale citite. Rezultatul se va afisa pe ecran.\nDe exemplu, pentru n=6 si numerele 728 , 10 , 103 , 44 , 1000 , 94 se va afisa : 1831 (reprezentand suma : 728+103+1000).\n15. Scrieti un program C/C++ care citeste din fisierul text BAC.TXT , cel mult 100 de numere naturale aflate pe o singura linie , formate din cel mult 9 cifre fiecare , separate prin spatii si dintre aceastea le afiseaza pe ecran doar pe acelea care au proprietatea de a fi palindrom. Daca nu se gasesc numere palindrom, se va afisa pe ecran valoarea –1. Un numar are proprietatea de a fi palindrom daca citit de la dreapta la stanga sau de la stanga la dreapta are aceeasi valoare. De exemplu 1221 este palindrom, in timp ce 1210 nu este palindrom.\nExemplu : daca din fisierul BAC.TXT se citesc numerele : 7341 , 8228 , 660 , 2 , 80 , 131 , atunci pe ecran se vor afisa : 828 , 2 , 131.\n16. Scrieti un program C/C++ care citeste un numar natural nenul n (n\u0026lt;100) si un sir de n numere naturale nenule de cel mult 4 cifre fiecare, si care afiseaza pe ecran sirul ordonat crescator in functie de suma cifrelor corespunzatoare fiecarui termen al sau. Daca doua numere au aceeasi suma a cifrelor se va afisa cel mai mic dintre ele. De exemplu pentru n=5 si numerele 701, 1000, 49, 99, 143, se va afisa sirul 1000 44 143 701 99.\n17. Pentru orice numar natural nenul n definim n factorial (notat n!) ca fiind produsul tuturor numerelor naturale nenule mai mici sau egale cu n (n! = 1*2*3*…*n) De exemplu : 3!=1*2*3=6 5!=1*2*3*4*5=120 . Scrieti un program C/C++ care determina a numarul de cifre nule aflate pe ultimile pozitii consecutive ale valorii obtinute in urma evaluarii lui n!, n fiind un numar natural de cel mult 4 cifre. De exemplu daca n=10, n!=3628800 rezultatul va fi 2 deoarece 3628800 are doi de 0 la sfarsit.\n18. Scrieti un program C/C++ care citeste de la tastatura un numar natural nenul n de cel mult 4 cifre si afiseaza pe ecran numarul de cifre nule aflate la sfarsitul lui n! De exemplu pentru n=6 se va afisa 0.\n19. Scrieti un program C/C++ care citeste din fisierul text DATE.IN cel mult 100 de numere naturale nenule aflate pe o singura linie, formate din cel mult 4 cifre fiecare, separate prin spatii si scrie in fisierul DATE.OUT, in ordine inversa fata de cea in care au fost citite pe o singura linie separate prin spatii. De exemplu daca din fisierul DATE.IN se citesc numerele 93 207 15 1982 3762, atunci continutul fisierului DATE.OUT va fi 3762 1982 15 207 93.\n20. Scrieti un program C/C++ care citeste de pe prima linie a fisierului text BAC.TXT , cel mult 100 de numere naturale nenule formate din cel mult 4 cifre fiecare , separate prin spatii si afiseaza pe ecran cifra care apare de cele mai multe ori in scrierea numerelor citite. Daca exista mai multe cifre care apar de cele mai multe ori , se vor afisa toate acestea. De exemplu , daca din fisier se citesc numerele : 90 , 73 , 109 , 1248 , 2771 , atunci afiseaza 1 , 7 , deoarece fiecare dintre aceastea apare de 3 ori.\n21. Scrieti un program C/C++ care citeste de pe prima linie a fisierului text BAC.TXT trei numere naturale a, b, c formate din cel mult patru cifre fiecare, separate prin cate un spatiu si afiseaza pe ecran cel mai mare divizor comun al acestora. De exemplu, daca din fisier se citesc numerele : 9 27 15, atunci se afiseaza 3.\n22. Se considera programul pseudocod în care s-a folosit notatia [x] pentru partea întreaga a lui x.\nciteste n (numar natural)\nrepeta\nn \u0026lt;- [n\\10]\npâna când n\u0026lt;10\nscrie n\nScrieti algoritmul pseudocod echivalent cu algoritmul dat, dar care sa utilizeze un alt tip de structura repetitiva.\n23. Se considera programul pseudocod în care s-a folosit notatia [x] pentru partea întreaga a lui x.\nciteste n (numar natural)\nrepeta\nn \u0026lt;- [n\\10]\npâna când n\u0026lt;10\nscrie n\nScrieti programul pentru algoritmul dat si care sa afiseze si numarul de repetitii efectuate de algoritm.\n24. Se considera subprogramul numar, care:\n– primeste prin intermediul unicului sau parametru, a, un numar natural de cel mult 4 cifre;\n– returneaza numarul divizorilor lui a;\nScrieti un program care stabileste daca un numar este prim utilizând aceasta functie.\n25. Scrieti un program care verifica daca un numar natural k(1\u0026lt;k2.\nDe exemplu, daca a=3 si b=5 atunci se va afisa « Da », iar pentru a=21 si b=5 se va afisa mesajul « Nu ».\n27. Se considera fisierul text date.in care contine exact 899 numere distincte formate fiecare din cate 3 cifre.Sa se afiseze in fisierul text date.out numarul format din 3 cifre care lipseste din fisierul date.in.\n28. Se citesc 2 numere naturale nenule m , n(2\u0026lt;m, n\u0026lt;20). Sa se scrie programul C/C++ care construieste în memorie o matrice A cu m linii si n coloane cu proprietatea ca elementul A[i][j] este egal cel mai mare divizor comun dintre numerele i si j. Matricea se va afisa pe ecran, câte o linie a matricei pe câte o linie a ecranului, elementele fiecarei linii fiind separate prin spatii. De exemplu pentru m=3 si n=4 se va afisa matricea urmatoare :\n1 1 1 1\n1 2 1 2\n1 1 3 1\n29. Se citeste de la tastatura un numar natural nenul n (n\u0026lt;1000). Scrieti un program C/C++ care construieste fisierul text bac.txt care sa contina, pe prima linie, toti divizorii lui n in ordine strict descrescatoare. Divizorii vor fi separati prin spatiu. De exemplu, daca n=10 , atunci fisierul bac.txt va contine : 10 , 5 , 2 , 1\n30. Se considera fisierul text Cuvinte.in ce contine pe prima linie un numar natural nenul n (n\u0026lt;=100) iar pe urmatoarele n linii cate un cuvant cu maximum 10 caractere. Sa se afiseze pe ecran cuvintele din fisierul dat care sunt palindroame. In cazul in care nu exista nici un cuvant palindrom se va afisa mesajul ”NU” .Un cuvant este palindrom daca citindu-l de la dreapta la stanga sau de la stanga la dreapta se obtine acelasi cuvant.\nDe exemplu daca fisierul Cuvinte.in are urmatorul continut :\n3\nsas\ncreion\nIon\naunci se va afisa pe ecran :\nsas\n31. Scrieti definitia unui subprogram sdiv cu doi parametri, subprogram care:\n– primeste prin intermediul parametrului n, un numar întreg de maxim 9 cifre;\n– returneaza prin intermediul celui de al doilea parametru k suma tuturor divizorilor lui n.\nDe exemplu pentru valoarea 6 a lui n, valoarea lui k va fi 12.\n32. Scrieti un program C/C++ care determina primele p perechi distincte de numere prietene. Fiecare pereche va fi afisata pe câte un rând, iar elementele unei perechi vor fi separate prin câte un spatiu. Doua numere naturale distincte a si b sunt numere prietene daca a este egal cu suma divizorilor lui b mai mici decât b, iar b este egal cu suma divizorilor lui a mai mici decât a. Valoarea numarului p se citeste de la tastatura. (1\u0026lt;=p\u0026lt;=8).\nDe exemplu pentru p=3 se vor afisa :\n220 284\n1184 1210\n2620 2924\n33. Se citeste de la tastatura un numar natural nenul n care are cel mult 9 cifre. Sa se afiseze in fisierul Date.out numarul k, natural, astfel incat produsul 1*2…(k-1)*k sa aiba o valoare cat mai apropiata de numarul n. De exemplu, daca se citeste numarul n=25 fisierul Date.out are urmatorul continut: 4. iar daca se citeste numarul n=119 fisierul Date.out are urmatorul continut: 5\n34.Pentru o valoare n(numar natural, 1\u0026lt;=n1 cu maximum 9 cifre, si afiseaza valoarea celui mai mic divizor prim a lui n, precum si puterea la care acest divizor apare in descompunerea in factori primi a numarului n.\n36. Scrieti programul C/C++ care citeste de la tastatura doua numere naturale n si x (x,n \u0026gt;1), cu maximum 9 cifre si verifica daca n este divizibil cu 2¬¬¬¬¬¬x. Programul afiseaza DA in caz afirmativ si NU in caz contrar.\n37. Se citeste de la tastatura un numar natural n (1\u0026lt;=n\u0026lt;=100).Sa se afiseze pe ecran al n-lea termen al sirului 11,22,33,44,55,66,77,88,99,111,222,333,444,etc.\nDe exemplu, daca n=11 se afiseaza 222.\n38. Scrieti programul C/C++ care citeste de la tastatura un numar natural n (2\u0026lt;n\u0026lt;30) si construieste in memorie o matrice patratica de n linii si n coloane formata numai din valori ce apartin multimii {1,2,3,…,n} astfel incat elementele din matrice situate pe diagonala secundara sa fie egale cu n, elementele situate pe celelalte doua « semidiagonale » paralele cu diagonala secundara, de o parte si de lata a acesteia, sa fie egale cu n-2 etc. Matricea se va afisa pe ecran cate o linie a matricei pe cate o linie a ecranului, cu spatii intre elementele fiecarei linii (ca in exemplu).\nDe exemplu, pentru n=5 se construieste in memorie si se afiseaza matricea :\n1 2 3 4 5\n2 3 4 5 4\n3 4 5 4 3\n4 5 4 3 2\n5 4 3 2 1\n39. Scrieti programul C/C++ care citeste de la tastatura un sir s de cel mult 30 de caractere si un caracter c ; programul realizeaza dublarea fiecarei aparitii a caracterului c in s si scrie noul sir obtinut in fisierul text BAC.TXT.\nDe exemplu, daca se citeste sirul alfabetar si caracterul a atunci fisierul BAC.TXT va contine sirul : aalfaabetaar.\n40. Scrieti un program care citeste de la tastatura doua siruri de caractere, fiecare sir fiind format din cel mult 100 de litere din alfabetul englez, si care afiseaza mesajul « DA » daca toate literele din primul sir se gasesc in cel de-al doilea sir, nu neaparat in aceeasi ordine si de acelasi numar de ori, sau mesajul « NU » in caz contrar. De exemplu, daca primul sir este « baraca » iar cel de-al doilea sir este « abracadabra », programul trebuie sa afiseze mesajul « DA » deoarece literele primului sir apar in cel de-al doilea sir.\n41. Pe prima linie a fisierului text BAC.TXT se afla un numar natural nenul n (2\u0026lt;=n\u0026lt;1000000), iar pe a doua linie a fisierului se afla un sir format din n numere intregi, despartite prin cate un spatiu, fiecare numar fiind format din cel mult 4 cifre. Stiind ca in fisier exista cel putin un numar strict pozitiv, se cere sa se afiseze lungimea maxima a unei secvente din sir care are proprietatea ca este formata doar din valori strict pozitive. O secventa a unui sir este format dintr-unul sau mai multe elemente aflate pe pozitii consecutive. Alegeti o metoda eficienta de rezolvare atat ca timp de executare, cat si ca gestionare a memoriei.\nDe exemplu, daca fisierul BAC.TXT are continutul\n10\n7 22 -3 10 3 14 0 21 10\natunci programul trebuie sa afiseze pe ecran doar valoarea 3, deoarece in sirul considerat exista mai multe secvente care sunt formate doar din numere strict pozitive, dar lungimea maxima a unei astfel de secvente este 3.\n42. Se citesc de la tastatura patru numerere naturale nenule a,b,c,d. Scrieti un program C/C++ care sa afiseze rezultatul expresiei a/b+c/d sub forma unei fractii ireductibile.\n43. Se citesc de la tastatura patru numerere naturale nenule a,b,c,d. Scrieti un program C/C++ care sa afiseze rezultatul expresiei a/b*c/d sub forma unei fractii ireductibile.\n44. Se citesc de la tastatura patru numerere naturale nenule a,b,c,d cu care se formeaza numerele complexe z=(a,b) si t=(c,d). Scrieti un program C/C++ care sa afiseze pe ecran rezultatul expresiei z*t.\n 45. Se citesc de la tastatura patru numerere naturale nenule a,b,c,d cu care se formeaza numerele complexe z=(a,b) si t=(c,d). Scrieti un program C/C++ care sa afiseze rezultatul expresiei z/t.   \n"
},
{
	"uri": "https://danielanicolae.com/programare/arbori/",
	"title": "Arbori",
	"tags": [],
	"description": "",
	"content": "  Fie un graf neorientat G=(V,U), unde V e mulțimea vârfurilor, iar U cea a muchiilor sale. Următoarele afirmații sunt echivalente:\n1. Geste arbore.\n2. Geste un graf conex minimal („minimal” se numește proprietatea unui graf, că dacă i se elimină orice muchie, se obține un graf neconex).\n3. Geste un graf fără cicluri maximal („maximal” se numește proprietatea unui graf, că dacă i se adaugă orice muchie, se obține un graf care are măcar un ciclu, și deci nu e arbore).\nUn arbore cu n ≥ 2 vârfuri conține cel puțin două vârfuri terminale. Orice arbore cu n vârfuri are n-1 muchii.\nUn arbore este o structura ramificata formata dintr-un nod A (radacina) si un numar finit de arbori (subarbori) ai lui A.\n- orice nod din arbore este radacina pentru un subarbore iar orice arbore poate deveni subarbore;\n- doi subarbori pot fi în relatie de incluziune, când un subarbore este inclus în celalalt sau de excluziune, când nu au noduri comune.\nDefinitii:\nnod = punct în care se întâlnesc doi subarbori;\nnivel = numarul de noduri parcurse de la radacina pâna la un nod;\nradacina = nivel 1;\ndescendent = primul nod al unui subarbore;\nnod terminal = nod fara descendenti;\nînaltimea unui arbore = numarul maxim de niveluri;\narbore binar = arbore în care toate nodurile au maximum 2 descendenti\nDacă avem în vedere faptul că un arbore binar este un arbore, care înainte de toate este un graf, putem spune că printre metodele de reprezentare a arborilor binari se numără şi metodele de reprezentare a grafurilor, cum ar fi:\n-reprezentarea prin matricea de adiacenţă;-reprezentarea prin listele de adiacenţă;-reprezentarea prin şirul muchiilor;Modalităţile de reprezentare specifice arborilor binari sunt:1.cu ajutorul vectorilor2.folosind alocarea dinamică\nSe numeşte arbore binar complet un arbore binar în fiecare nod, care nu este frunză, are exact doi descendenţi.\nPropoziţie:Un arbore binar complet care are p noduri terminale, toate situate pe acelaşi nivel, are în total 2p-1 noduri.\nParcurgerea arborilor binari\nARBORI GENERALIZATI/BINARI\nhttp://bigfoot.cs.upt.ro/~chirila/teaching/upt/lectures/2id-aa/AA-ID-Cap08-1.pdf\nVezi\nhttp://informaticasite.ro/probleme-rezolvate-c++/arbori/\nProbleme propuse test_grafuri_neorientate1.docx test_grafuri_neorientate2.docx\ntest_grafuri_neorientate3.docx\n1. Elevii unei clase stau in banca cate doi sau cate unul singur. Cand este nevoie sa se faca un anunt urgent la sfarsit de saptamana sau in vacanta, ei au stabilit un sistem prin care un elev va anunta pe altii doi care sunt colegi de banca, sau pe unul singur, daca nu are coleg de banca (exista si elevi care nu vor da telefoane mai departe). Stiind ca doamna diriginta face primul anunt (anunta doi elevi care sunt colegi de banca) si apoi fiecare elev isi anunta alti doi colegi de banca (sau unul sau niciunul) de clasa si asa mai departe, se cere sa se scrie un program care realizeaza urmatoarele:\na) memorarea datelor intr-un arbore binar alocat in heap. Un elev inexistent se va marca cu * ARBORE.cxx\nb) numara si afiseaza din cati elevi este formata clasa\nc) afiseaza numele tuturor elevilor din clasa\nd) sa se determine daca un elev face parte din clasa\ne) sa se afiseze elevii anuntati de diriginta\nf) sa se afiseze cologii de banca (perechi)\ng) numara cati elevi au acelasi nume cu un nume dat de la tastatura\nh) afiseaza numele elevilor care nu mai au de anuntat pe nimeni\ni) sa se afiseze colegul de banca al lui Gigel (sau un nume citit de la tastatura)\nj) cine ar fi trebuit sa il anunte pe Dan (sau un nume citit de la tastatura)\nk) sa se afiseze elevii care stau in stanga in banci\nl) elevul x si elevul y isi schimba locurile. Sa se afiseze.\nm) cate banci sunt ocupate de un singur elev\nn) cate banci sunt ocupate de doi elevi\no) cate banci sunt ocupate\n2. Un arbore binar retine numere intregi.\na) sa se afiseze numerele utilizand una dintre metode.\nb) sa se afiseze numerele pare din arbore\nc) sa se determine cel mai mare numar din arbore\nd) sa se determine suma cifrelor tuturor numerelor din arbore\ne) afisati frunzele\nf) sa se determine daca exista o anumita valoare in arbore\ng) sa se determine daca arborele contine numere prime\nh) sa se genereze oglinditul arborelui\ni) sa se afiseze subordonatii stangi\nj) sa se inlocuiasca o cheie cu o alta\nk) sa se inverseze doua chei\nl) sa se afiseze fratele lui x\nm) sa se afiseze tatal lui x\nn) sa se afiseze fii (fiul) lui x\no) sa se determine minimul din arbore\np) sa se afiseze nodurile cu un singur subordonat\n2. Fie un arbore binar memorat prin vectorii stang si drept. Sa se parcurga arborele prin cele trei metode.\n3. Fiind dat un arbore binar memorat in heap, sa se genereze un nou arbore binar identic cu primul.\n4. Fie un arbore binar memora in heap. \na) Sa se afiseze cate niveluri are arborele\nb) Sa se afiseze nodurile de pe nivelul x\nc) sa se afiseze nodurile pe niveluri\nd)Calculati si afisati suma nodurilor de pe un nivel dat\ne) sa se afisese frunzele care nu se gasesc pe ultimul nivel\n5.Un arbore binar retine caractere.\na) sa se determine cate vocale retine arborele\nb) se citeste un sir de caractere de la tastatura. Sa se determine daca sirul citit este egal cu sirul determinat de parcurgerea arborelui (svd, vsd sau sdv).\n6. Fie un graf orientat memorat prin matricea de adiacenta. Sa se determine daca graful poate fi arbore binar. In caz afirmativ , pentru o solutie oarecare, sa se parcurga svd.\n7. Fie un arbore binar. Sa se completeze arborele astfel incat fiecare nod sa aiba 2 subordonati. Valoarea cu care se face completarea se citeste de la tastatura.\n8. Fie un arbore binar cu n noduri numerotate de la 1 la n cu radacina 1, in care cheia fiecarui nod este un numar intreg. Numarul de noduri se citeste de la tastatura. Reprezentarea in memorie se face inlantuit cu referinte descendente astfel: pe fiecare dintre cele n randuri ale fisierului text arbore.in se afla cate trei numere intregi, separate prin cate un spatiu reprezentand fiul stang, fiul drept si valoarea cheii fiecarui nod al arborelui. Sa se scrie cate un program C++ pentru fiecare dintre\ncerintele de mai jos:\na) sa se afiseze nodurile care retin informatiile numere pare;\nb) sa se afiseze nodurile care au doar descendent stang;\nc) sa se afiseze cheile nodurilor care au doar descendent drept;\nd) sa se afiseze cheile din nodurile terminale;\ne) sa se afiseze fiii nodului x, furnizat de utilizator;\nf) sa se afiseze nodul tata al unui nod x, furnizat de utilizator;\ng) sa se scrie in fisierul noduri.out, nodurile ale caror chei sunt egale cu o valoare val,\ncitita de la tastatura;\nh) sa se calculeze inaltimea arborelui binar dat;\ni) sa se determine nivelul maxim;\nj) sa se afiseze cheia maxima.   \n"
},
{
	"uri": "https://danielanicolae.com/programare/arbori_de_cautare/",
	"title": "Arbori de Cautare",
	"tags": [],
	"description": "",
	"content": "  Arbori de cautare.docx\nB TREES\nb-trees.ppt\nDEFINITII COMPLEXE\narbori.pdf   \n"
},
{
	"uri": "https://danielanicolae.com/programare/backtracking/",
	"title": "Backtracking",
	"tags": [],
	"description": "",
	"content": "  Metoda backtracking se aplica problemelor in care solutia se poate prezenta sub forma unui vector x={x1,x2,…,xn} unde x1 apartine unei multimi S1, x2 apartine multimii S2 s.a.m.d.Si i=1…n sunt multimi finite. Cerinta problemei este, de obicei, gasirea tuturor solutiilor posibile sau gasirea numarului de solutii care satisfac anumite conditii specifice problemei. De multe ori metoda se foloseste si pentru gasirea unei singure solutii (dupa gasirea acesteia se intrerupe executia programului), a unei solutii maxime/minime insa, pentru astfel de cazuri recomandam gasirea unei alte solutii de rezolvare datorita faptului ca metoda Backtracking consuma resurse mari de memorie si timp.\nConditiile interne, numite si conditii de continuitate, sunt acele conditii care trebuie indeplinite de un element pentru a fi adaugat la solutie. Validitatea elementului se verifica in functie de elementele aflate in fata lui in vectorul solutie (vectorul x).\nMetoda evita generarea tuturor solutiilor posibile. Se va cauta obtinerea unei solutii prin alegerea succesiva de elemente din multimile S1, S2, S3,…,Sn. Astfel, la pasul k, se va alege un element xk din multimea Sk. Inainte de a trece la pasul k+1, se verifica daca sunt satisfacute conditiile de continuitate. In cazul in care pentru o valoare xk aleasa, conditiile de continuare nu sunt satisfacute, se va alege o alta valoare din multimea Sk, pana cand fie se va gasi o valoare care sa satisfaca conditiile de continuitate, fie se epuizeaza toate elementele multimii Sk. In cazul in care se gaseşte un element xk convenabil avem doua cazuri: fie s-a ajuns la obtinerea unei solutii caz in care se afiseaza solutia, fie nu s-a ajuns la o solutie caz in care se trece la gasirea urmatorului element din vectorul solutie (cel de pe pozitia k+1). Exista şi cazul in care pozitia k din vectorul solutie nu s-a putut completa cu un element xk din Sk, adica nu s-a gasit un element care sa indeplineasca conditiile de continuitate. In acest caz se va reveni la pasul anterior (k-1). Se va renunta la valoarea x(k-1) aleasa şi se va cauta alegerea unei alte valori (urmatoarea valoare din multimea k-1).\nCa orice algoritm in care sunt prezente instructiuni repetitive, algoritmul backtracking poate fi reprezentat intr-o maniera recursiva sau nerecursiva.\nAPLICATII\n1. Dintr-un numar de 6 cursuri opţionale un elev trebuie să aleagă 3. Să se afişeze toate posibilităţile de alegere precum şi numarul lor.\n2.Lui IRINEL îi plac nr. formate numai din cifre pare cifre aflate în ordine descrescătoare. Să se determine şi să se afişeze pe ecran toate nr. de n cifre (0\u0026lt;n\u0026lt;10) care îi plac lui Irinel. Valoarea lui n este un nr. natural care se citeşte de la tastatură.{ex.: n=3 200; 220; 222; 400; 402; 422; 440; 442; 444; 600; 620; 622; 640; 644; 660; 662; 664; 666; 800; 820; 822; 840; 842; 844; 860; 862; 864; 866; 880; 882; 884; 886; 888.} \n3.Problema celor n dame. Fiind dată o tablă de şah n´n se cer toate soluţiile de aranjare a n dame, astfel încât să nu se afle două dame pe aceeaşi linie, coloană sau diagonală (damele să nu se atace reciproc).\n4..PROBLEMA COLORARII HARTILOR: Fiind dată o hartă cu n ţări, se cer toate soluţiile de colorare a hărţii, utilizând cel mult patru culori, astfel încât două ţări de frontieră comună să fie colorate diferit. Este demonstrat faptul că sunt suficiente numai patru culori pentru ca orice hartă să poată fi colorată.\n5. PROBLEMA DRAPELELOR : Avem la dipoziţie 6 culori: alb, galben, roşu, verde, albastru, negru. Să se precizeze toate drapelele tricolore care se pot proiecta, ştiind că trebuie respectate regulile:\n- orice drapel are culoarea din mijloc galben sau verde \n- cele trei culori de pe drapel sunt distincte. \nObservaţie: utilizaţi facilităţile unit-ului crt, în afişarea culorilor drapelelor generate\n6. Produsul cartezian a n mulţimi. Se dau mulţimile de mai jos şi se cere produsul cartezian al lor.\nA1 = {1, 2, 3, …, k1}\nA2 = {1, 2, 3, …, k2}\n………………………\nAn = {1, 2, 3, …, kn}\n7. TURNURI DE CUBURI Se dau n cuburi numerotate 1,2,\u0026hellip;,n, de laturi Li si culori Ci, i=1,2,\u0026hellip;,n (fiecare culoare este codificata printr-un caracter). Sa se afişeze toate turnurile care se pot forma luând k cuburi din cele n disponibile, astfel încât:\n-laturile cuburilor din turn sa fie in ordine crescătoare;\n-culorile a oricare doua cuburi alăturate din turn sa fie diferite.\n8. Problema comis-voiajorului. Un comis voiajor trebuie să viziteze un număr n de oraşe. Iniţial, el se află într-unul dintre ele, notat 1. Comis – voiajorul doreşte să nu treacă de două ori prin acelaşi oraş, iar la întoarcere să revină în oraşul 1. Cunoscând legăturile existente între oraşe, se cere să se tipărească toate drumurile posibile pe care le poate efectua comis – voiajorul.\n9 Sa se genereze partitiile nr.natural n.partitii.cpp\nex.n=5\n5=1+1+1+1+1\n5=1+1+1+2\n5=1+1+3\n5=1+4\n5=5.\n10.\n 10. Se citeste de la tastatura un numar natural n par, n\u0026lt;30. Sa se genereze si sa se afiseze pe ecran toate combinatiile de n paranteze rotunde care se închid corect. De exemplu, pentru n=4 se obtin urmatoarele combinatii: ( ( ) ) si ( ) ( ) .PARANTEZE.CPP\n   \n11.Se citeste un numar natural n\u0026lt;30. Sa se afiseze toate modalitatile de a-l calcula prin adunari sau scaderi ale numerelor 1,2, \u0026hellip;n. Fiecare numar de la 1 la n va aparea o singura data în descompunerea lui n. Daca acest lucru nu este posibil, se va afisa mesajul „Imposibil”.\nExemplu:\n5=1+2+3+4-5\n5=1-2-3+4+5\n5=-1+2+3-4+5\nSUMA.CPP\nLISTA PROBLEME backtracking_proiect.docx subiecte_informatica_limbajulc(sub_3).zip GRILE BACKTRACKING grile backtracking.pdf   \n"
},
{
	"uri": "https://danielanicolae.com/programare/baze_de_date/",
	"title": "Baze de Date",
	"tags": [],
	"description": "",
	"content": "   Proiectarea bazelor de date from aaa zAZ   \n"
},
{
	"uri": "https://danielanicolae.com/programare/c_builder/",
	"title": "C Builder",
	"tags": [],
	"description": "",
	"content": "  C++Builder   \n"
},
{
	"uri": "https://danielanicolae.com/programare/compilatoare_mingw/",
	"title": "Compilatoare MinGW",
	"tags": [],
	"description": "",
	"content": "  La adresa :\nhttp://infoarena.ro/schimbare-borland/pachet\nalegeti :\nPachet cu compilatorul MinGW 4.4, GDB 7.1 si Code::Blocks\nhttp://www.cprogramming.com/code_blocks/   \n"
},
{
	"uri": "https://danielanicolae.com/programare/foxpro/",
	"title": "Compilatoare MinGW",
	"tags": [],
	"description": "",
	"content": "  DomnulTudor - FOXPRO    Baze de Date in Visual Foxpro.pdf SGBD.pdf Visual-Foxpro-Decriptat.pdf  FOXPRO_SUPORT_DE_CURS.pdfVisual_Fox_Pro1.doc\nComenzi_Fox_Pro.docVisual_FoxPro2.doc  PROGRAMARE STRUCTURATA-INSTRUCTIUNI.docx SUBPROGRAME.docx TESTE TEST.pdf\nTEST1.doc\nTEST2.doc\nTEST3.doc\nTEST4.doc\nTEST5.doc\nTEST6.doc\nFISE DE LUCRU aplicatii foxpro.doc\nFISA DE LUCRU1.pdf\nFISE DE LUCRU 3.pdf\nFISE DE LUCRU 2.pdf\nFISE DE LUCRU.pdfAPLICATII CU SUBPROGRAME.docx   \n"
},
{
	"uri": "https://danielanicolae.com/programare/comunicarea_re%C5%A3ea_locala/",
	"title": "Comunicarea intr-o Retea Locala",
	"tags": [],
	"description": "",
	"content": "  1. Functionarea echipamentelor intr-o retea locala.pdf huburi versus switch-uri versus routere.docx\n2. Medii de comunicare prin fire de cupru.pdf 3. Medii de comunicare prin fibra optica.pdf\nFisa_Tema3.doc MP6_Comunicarea intr-o retea locala (LAN) - partea 2.doc\nSUPORT DE INVATARE ONLINE\nCum diferă huburile, switchurile, ruterele și punctele de acces?\nWIKIPEDIA-Echipamente pentru realizarea rețelelor de calculatoare\nMP5_Comunicarea Intr-o Retea Locala (LAN) - Partea 1\n   \n"
},
{
	"uri": "https://danielanicolae.com/programare/conexitate_grafuri_neorientate/",
	"title": "Conexitate in Grafuri Neorientate",
	"tags": [],
	"description": "",
	"content": "  Algoritmul Roy-Warshall:Exista drum intre nodul x si nodul y? #include \u0026lt;iostream\u0026gt;#include \u0026lt;conio.h\u0026gt;\nusing namespace std;\nint main()\n{\nint n,i,a[100][100],j,k,x,y;\ncout\u0026lt;\u0026lt;\u0026quot;n=\u0026quot;;cin\u0026gt;\u0026gt;n;\nfor(i=1;i\u0026lt;=n;i++)\nfor(j=1;j\u0026lt;=n;j++)\n{cout\u0026lt;\u0026lt;\u0026quot;a[\u0026quot;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026quot;][\u0026quot;\u0026lt;\u0026lt;j\u0026lt;\u0026lt;\u0026quot;]=\u0026quot;;\ncin\u0026gt;\u0026gt;a[i][j];\n}\nfor(k=1;k\u0026lt;=n;k++)\nfor(i=1;i\u0026lt;=n;i++)\nfor(j=1;j\u0026lt;=n;j++)\nif(a[i][j]==0\u0026amp;\u0026amp; i!=k\u0026amp;\u0026amp;j!=k)\na[i][j]=a[i][k]*a[k][j];\ncout\u0026lt;\u0026lt;\u0026quot;Nodul initial:\u0026quot;;cin\u0026gt;\u0026gt;x;\ncout\u0026lt;\u0026lt;\u0026quot;Nodul final:\u0026quot;;cin\u0026gt;\u0026gt;y;\nif(a[x][y]==1)\ncout\u0026lt;\u0026lt;\u0026quot;Exista drum intre nodul \u0026quot;\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026quot; si nodul \u0026quot;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;\u0026quot;.\u0026quot;;\nelse\ncout\u0026lt;\u0026lt;\u0026quot;NU exista drum intre nodul \u0026quot;\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026quot; si nodul \u0026quot;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;\u0026quot;.\u0026quot;;\ngetch();\nreturn 0;\n}\nConexitate în grafuri neorientate.pptx  CONEXITATE IN GRAFURI NEORIENTATE\n\u0026lt;!\u0026ndash; /** * GeSHi \u0026copy; 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann * (http://qbnz.com/highlighter/ and http://geshi.org/) */ .text {font-family:monospace;} .text .imp {font-weight: bold; color: red;} .text span.xtra { display:block; }\n\u0026ndash;\u0026gt; #include\u0026lt;fstream\u0026gt; using namespace std; int k,m,n,x[100],a[100][100],p[100]; \u0026nbsp; fstream f(\u0026quot;date.in\u0026quot;,ios::in); fstream g(\u0026quot;date.out\u0026quot;,ios::out); \u0026nbsp; void citire() {int x,y; f\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=m;i++) {f\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; a[x][y]=1; a[y][x]=1; } } void rw() {int i, j, k; for(k=1;k\u0026lt;=n;k++) for(i=1;i\u0026lt;=n;i++) for(j=1;j\u0026lt;=n;j++) if(i!=j) if(a[i][j]==0) a[i][j]=a[i][k]*a[k][j]; } void afis() {for(int i=1;i\u0026lt;=n;i++) if(!p[i]) { g\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026quot; \u0026quot;; p[i]=1; for(int j=1;j\u0026lt;=n;j++) if(a[i][j]) { g\u0026lt;\u0026lt;j\u0026lt;\u0026lt;\u0026quot; \u0026quot;; p[j]=1;} g\u0026lt;\u0026lt;endl; } } \u0026nbsp; int main() {citire(); rw(); afis(); f.close(); g.close(); return 0; } \u0026nbsp; \u0026lt;/span\u0026gt;\n \u0026lt;/div\u0026gt;   \n"
},
{
	"uri": "https://danielanicolae.com/programare/curs_c/",
	"title": "Curs C",
	"tags": [],
	"description": "",
	"content": "  Curs C++.rar   \n"
},
{
	"uri": "https://danielanicolae.com/programare/divide_et_impera/",
	"title": "Divide et Impera",
	"tags": [],
	"description": "",
	"content": "  Divide et impera se bazează pe principiul descompunerii problemei în două sau mai multe subprobleme (mai ușoare), care se rezolvă, iar soluția pentru problema inițială se obține combinând soluțiile subproblemelor. De multe ori, subproblemele sunt de același tip și pentru fiecare din ele se poate aplica aceeași tactică a descompunerii în (alte) subprobleme, până când (în urma descompunerilor repetate) se ajunge la probleme care admit rezolvare imediată.\nNu toate problemele pot fi rezolvate prin utilizarea acestei tehnici. Se poate afirma că numărul celor rezolvabile prin \u0026quot;divide et impera\u0026quot; este relativ mic, tocmai datorită cerinței ca problema să admită o descompunere repetată.\nDivide et impera este o tehnică ce admite o implementare recursivă. Principiul general prin care se elaborează algoritmi recursivi este: \u0026quot;ce se întâmplă la un nivel, se întâmplă la orice nivel\u0026quot; (având grijă să asigurăm condițiile de terminare). Așadar, un algoritm prin divide et impera se elaborează astfel: la un anumit nivel avem două posibilități:\ns-a ajuns la o problemă care admite o rezolvare imediată (condiția de terminare), caz în care se rezolvă și se revine din apel;nu s-a ajuns în situația de la punctul 1, caz în care problema curentă este descompusă în (două sau mai multe) subprobleme, pentru fiecare din ele urmează un apel recursiv al funcției, după care combinarea rezultatelor are loc fie pentru fiecare subproblemă, fie la final, înaintea revenirii din apel.Aplicații Maximul dintr-un vector Se citește un vector cu n componente, numere naturale. Se cere să se tipărească valoarea maximă.\nFuncția căutată va genera valoarea maximă dintre numerele reținute în vector pe o poziție dintre i și j (inițial, i=1, j=n). Pentru aceasta, se procedează astfel:\ndacă i=j, valoarea maxima va fi v[i];în caz contrar, se imparte vectorul în doi subvectori - presupunem varianta pentru paralelizare pe 2 procesoare. Se calculează mijlocul m al intervalului [i, j]: m = (i+j) div 2. Primul subvector va conține componentele de la i la m, al doilea va conține componentele de la (m+1) la j; se rezolvă subproblemele (aflându-se astfel maximul pentru fiecare din subvectori), iar soluția curentă va fi dată de valoarea maximă dintre rezultatele celor două subprobleme.\n#include \u0026lt;iostream\u0026gt;\nusing namespace std;\nint v[10],n;\nint max(int i, int j)\n{ int a, b, m;\nif (i==j) return v[i];\nelse { m = (i+j)/2;\na = max(i, m);\nb = max(m+1, j);\nif (a\u0026gt;b) return a; else return b; } }\nint main( )\n{ cout\u0026lt;\u0026lt;”n=”;cin\u0026gt;\u0026gt;n;\nfor (int i=1; i\u0026lt;=n; i++) \n{ cout\u0026lt;\u0026lt;”v[“\u0026lt;\u0026lt;i\u0026lt;\u0026lt;”]=”; cin\u0026gt;\u0026gt;v[i]; }\ncout\u0026lt;\u0026lt;”max=”\u0026lt;\u0026lt;max(1,n);\nreturn 0; }\nCăutare binară\nSe citește un vector cu n componente numere întregi (numerele se presupun ordonate crescător) și o valoare întreagă (\u0026quot;nr\u0026quot;). Să se decidă dacă nr se găsește sau nu printre numerele citite, iar în caz afirmativ să se tipărească indicele componentei care conține această valoare.\nO rezolvare în care nr se compară pe rând cu toate cele n componente reperzintă o pierdere de performanță (nu exploatează faptul că cele n valori sunt în secvență crescătoare). Algoritmul care va fi propus este optim și se poate spune că face parte dintre algoritmii \u0026quot;clasici\u0026quot;.\nFuncția care va fi implementată va decide dacă valoarea căutată se găsește printre numerele aflate pe poziții de indice cuprins între i și j (inițial, i=1, j=n). Pentru aceasta, se va proceda astfel:\ndacă nr coincide cu valoarea de la mijloc, aflată pe poziția de indice (i+j)/2, se tipărește indicele și se revine din apel (problema a fost rezolvată).în caz contrar, dacă mai sunt și alte elemente de analizat (adică i\u0026lt;j, deci nu au fost verificate toate pozițiile necesare), problema se descompune astfel:dacă nr este mai mic decât valoarea testată (din mijloc), înseamnă că nu se poate afla pe pozițiile din partea dreaptă, întrucât acestea sunt cel puțin mai mari decât valoarea testată. Nr se poate găsi doar printre componentele cu indice între i și (i+j)/2 - 1, caz în care se reapelează funcția cu acești parametri;dacă nr este mai mare decât valoarea testată (din mijloc), înseamnă că nu se poate afla în stânga; se poate găsi doar printre componentele cu indicele între (i+j)/2 + 1 și j, caz în care se reapelează funcția cu acești parametri.dacă nu mai sunt alte elemente de analizat (pentru că i=j și valoarea din mijloc, v[i], nu coincide cu nr), se concluzionează că nr nu apare în cadrul vectorului.Această problemă nu mai necesită analiza tuturor subproblemelor în care se descompune, ea se reduce la o singură subproblemă, iar partea de combinare a soluțiilor dispare. În linii mari, această rezolvare este tot de tip \u0026quot;divide et impera\u0026quot;.\n#include \u0026lt;iostream\u0026gt;\nusing namespace std;\nint v[100], n, nr;\nvoid caut(int i, int j)\n{int m = (i+j)/2;\nif (nr==v[m])\ncout\u0026lt;\u0026lt;”gasit, indice=”\u0026lt;\u0026lt;m;\nelse \nif (i\u0026lt;j)\nif (nr\u0026lt;v[m])\ncaut(i, m-1);\nelse caut(m+1, j);\nelse cout\u0026lt;\u0026lt;”nu a fost gasit.”;\n}\nint main( )\n{cout\u0026lt;\u0026lt;”n=”; cin\u0026gt;\u0026gt;n;\nfor (int i=1; i\u0026lt;=n; i++)\n{cout\u0026lt;\u0026lt;”v[“\u0026lt;\u0026lt;i\u0026lt;\u0026lt;”]=”; cin\u0026gt;\u0026gt;v[i];\n}\ncout\u0026lt;\u0026lt;”nr=”; cin\u0026gt;\u0026gt;nr;\ncaut (1,n);\nreturn 0;\n}\nQUICKSORT Functia poz rezolva o portiune din vector cuprinsa intre indicii p si u piv=v[p] este un reper.La sfarsitul executiei acestei functii piv se va gasi pe o pozitie k cuprinsa intre p si u astfel incat toate componentele vectorului cuprinse intre p si k-1 vor fi mai mici decat piv iar componentele cuprinse intre k+1 si u vor fi mai mari decat piv. Deci piv se va gasi pe pozitia k corespunzatoare ordinii in vector\n#include \u0026lt;iostream.h\u0026gt;\n#include \u0026lt;conio.h\u0026gt;\n#include\u0026lt;stdlib.h\u0026gt;\nint x[2000],n;\nint poz(int p,int u)\n{int piv,aux,k;\npiv=x[p];\nwhile (p\u0026lt;u)\n{ if (x[p]\u0026gt;x[u]) {aux=x[p];\nx[p]=x[u];\nx[u]=aux;}\nif (x[p]==piv)\nu\u0026ndash;;\nelse p++;}\nk=p;\nreturn k;}\nvoid quick(int p,int u)\n{int k;\nif (p\u0026lt;u)\n{k=poz(p,u);\nquick(p,k-1);\nquick(k+1,u);}}\nvoid main()\n{clrscr();\ncout\u0026lt;\u0026lt;\u0026quot;n=\u0026quot;;\ncin\u0026gt;\u0026gt;n;\nfor(int i=1;i\u0026lt;=n;i++)\n{cout\u0026lt;\u0026lt;\u0026quot;x[\u0026quot;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026quot;]=\u0026quot;;\ncin\u0026gt;\u0026gt;x[i];}\nquick(1,n);\nfor(i=1;i\u0026lt;=n;i++)\ncout\u0026lt;\u0026lt;x[i]\u0026lt;\u0026lt;\u0026rsquo; \u0026lsquo;;\ngetch();}\nTURNURILE DIN HANOI Turnurile Din Hanoi//\u0026lt;![CDATA[ (function() { var scribd = document.createElement(\u0026ldquo;script\u0026rdquo;); scribd.type = \u0026ldquo;text/javascript\u0026rdquo;; scribd.async = true; scribd.src = \u0026ldquo;http://www.scribd.com/javascripts/embed_code/inject.js\u0026quot;; var s = document.getElementsByTagName(\u0026ldquo;script\u0026rdquo;)[0]; s.parentNode.insertBefore(scribd, s); })(); //]]\u0026gt; \nPROBLEME PROPUSE 1. Se citeste un numar natural n si n numere naturale. Sa se calculeze cel mai mare divizor comun al celor n numere, folosind un algoritm Divide et Impera.\n2. Scrieti un program pentru determinarea minimului dintr-un sir de numere intregi, folosind Divide et Impera.\n3. Scrieti un program pentru calculul sumei valorilor dintr-un sir de numere intregi, folosind Divide et Impera.\n4. Sa se determine cate elemente pare are un vector\n5. Fie un tablou neordonat de numere intregi. Sa se determine prin metoda D\u0026amp;I de cate ori apare in tablou o anumita valoare v.\n6. Să se calculeze n!\n7. Să se calculeze simultan produsul şi suma a n numere memorate într-un vector.\n8. Să se calculeze suma 1x2+2x3+3x4+\u0026hellip;+nx(n+1).\n9. Să se calculeze suma 1x2+1x2x3+\u0026hellip;+1x2x3x\u0026hellip;xn.\n10. Să se numere elementele divizibile cu 5 dintr-un vector.\n11. Să se verifice dacă un vector conţine numai numere pozitive sau numai numere negative.\n12. Sa se gaseasca intr-un vector cu n elemente un element cu proprietatea ca valoarea lui este egala cu pozitia pe care apare. (a[k]=k)\n13. Scrieti o functie ce inverseaza un sir de caractere\n14. Să se afişeze dacă un cuvânt este palindrom.\n15. Să se verifice dacă un şir de numere este simetric.\n16. Sa se determine valoarea unui polinom intr-un punct\n17. Se citesc numele si inaltimile a n persoane.\na) Sa se afiseze persoanele avand inaltimea mai mare sau egala cu un h citit.\nb) Sa se ordoneze crescator persoanele dupa inaltime.\nc) Sa se afiseze o persoana avand o inaltime data. Daca nu exista o astfel de persoana se va afisa un mesaj.\n18. Se citesc numele a n persoane si inaltimile\na) Sa se determine daca persoanele sunt ordonate dupa inaltime\nb) Sa se afiseze persoana cea mai inalta\nc) Care este inaltimea medie?\nd) Sa se ordoneze alfabetic persoanele prin metoada QuickSort\ne) Sa se afiseze inaltimea unei persoane al carei nume se va citi de la tastatura (cautare binara dupa nume)\nf) Sa se ordoneze persoanele descrescator dupa inaltime utilizand MergeSort\ng) Sa se afiseze toate persoanele cu inaltimea mai mare de 1.70\nh) Sa se determine cate persoane au inaltimea 1.80   \n"
},
{
	"uri": "https://danielanicolae.com/programare/e-learning/",
	"title": "E-Learning",
	"tags": [],
	"description": "",
	"content": "  Platforma Moodle Manual_profesor_platforma_elearning.pdf   \n"
},
{
	"uri": "https://danielanicolae.com/programare/evaluare_platforma_wiki/",
	"title": "Evaluare Platforma Wiki",
	"tags": [],
	"description": "",
	"content": "  Chestionar pentru evaluare curs de catre elevi\nDenumire platformă:\nLocul instruirii: e-Learning\nInstituţia de înăţământ:……..\nScopul acestui chestionar este de a face o evaluare a eficientei instruirii si de ajuta la cresterea calitatii activitatilor de instruire\nA.- ASPECTE GENERALE\nA.1Evaluati, la modul general, organizarea activitatii de instruire:\n5 4 3 2 1\nA.2Evaluati gradul in care asteptarile voastre au fost satisfacute:\n5 4 3 2 1\nA.3Evaluati gradul in care obiectivele referitoare la instruire au fost realizate:\n5 4 3 2 1\nA.4Evaluati urmatoarele aspecte ale instructiei:\nDurata: ¨Scurta ¨Adecvata ¨Excesiva\nInteresul:5 4 3 2 1 \nAplicabilitatea: 5 4 3 2 1 \nRitmul:  ¨Lent ¨Adecvat ¨Excesiv\nTematica curenta: 5 4 3 2 1 \nConsiderati ca instruirea \nva ajuta in activitate:  ¨Personala ¨La scoala ¨Nu stiu\n5: Excelent 1: Deficitar\nB.- RESURSE MATERIALE B.1Evaluati facilitatile:\n5 4 3 2 1\nB.2Evaluati documentele transmise\n5 4 3 2 1\n5: Excelent 1: Deficitar\nC.- PROFESOR: C.1 Evaluati urmatoarele aspecte ale activitatilor desfasurate de PROFESOR:\nGradul de accesibilitate 5 4 3 2 1\nClaritate in prezentare 5 4 3 2 1\nCunoastere 5 4 3 2 1\nIncurajare participare 5 4 3 2 1 Interes 5 4 3 2 1 5: Excelent 1: Deficitar\n D-COMENTARII\n Data:\n \n   \n \n D- COMENTARII __  \n    \u0026lt;/div\u0026gt;   \n"
},
{
	"uri": "https://danielanicolae.com/programare/evaluare_portofolii/",
	"title": "Evaluare Portofolii",
	"tags": [],
	"description": "",
	"content": "  Materiale care va vor ajuta in evaluarea/autoevaluarea propriului demers didactic fi_deobserva_ieechipe.doc\ngrila_criterii_prezentare.doc\nNotare_potofoliu.doc\nAutoevaluare_colaborare_echipa.doc   \n"
},
{
	"uri": "https://danielanicolae.com/programare/expresii/",
	"title": "Expresii",
	"tags": [],
	"description": "",
	"content": "  Aplicaţii EXPRESII\n1. Daca a si b sunt variabile numerice a=3, b=10 sa se evalueze urmatoarele expresii:\na) 2*a – 3*b\nb) sqr(2)+sqr(a+b)\nc) (sqr(a)\u0026lt;b) si (sqr(b)\u0026lt;=100)\nd) (a % 2==0) sau (b % 2==0)\n2. Daca a=1831 si b=291 sunt doua variabile numerice, evaluati urmatoarele expresii:\na) (a-b)*a% 10\nb) (sqr(b))% 10\nc) (a / 10 \u0026lt;b) sau (b %10 \u0026lt; a % 10)\n3. Pentru doua numere reale a si b scrieti o expresie care calculeaza suma dintre media aritmetica si media geometrica a celor doua numere\n4. Fiind dat un numar natural de 3 cifre, n, scrieti o expresie care calculeaza produsul cifrelor sale\nSe reaminteste faptul ca ultima cifra a unui numar natural este dat de relatia n mod 10 si pe baza acestui fapt se porneste la determinarea celorlalte cifre ale numarului care vor fi pe rand determinate\n5. Scrieti o expresie care sa fie adevarata daca si numai daca numerele a si b sunt divizibile cu 5\n6. Scrieti o expresie care sa fie adevarata daca si numai daca numarul n este patrat perfect\nFISE DE LUCRU\nEXPRESII.pdf   \n"
},
{
	"uri": "https://danielanicolae.com/programare/fisiere_text/",
	"title": "Fisiere Text",
	"tags": [],
	"description": "",
	"content": "  Declararea, închiderea şi deschiderea fişierelor în C++ utilizează anumite clase şi funcţii care sunt declarate în biblioteca fstream.h.\n#include\u0026lt;fstream.h\u0026gt;\nDeclararea fişierelor\nPentru a putea citi/scrie informaţii dintr-un/într-un fişier, acesta se asociază unui stream (flux) de intrare/ieşire.\nifstream nume_fişier_logic (nume_fişier);deschiderea unui fisier pentr a citi date\nofstream nume_fişier_logic (nume_fişier);\ndeschiderea unui fisier pentru a scrie date\nExemplu:\nfisier de intrare fişier de iesire\nifstream f(”numere.in”); ofstream g(”numere.out”);\nCrearea unui fisier cu date ce urmeaza a fi citite prin program\nFILEàNewà\n- scriem date in fisier\n- salvam fisierul cu numele specificat intre parantezele rotunde ale functiei ifstream \n(de exemplu numere.in)CITIREA datelor\n de la tastatura\n din fisier\n   #include\u0026lt;iostream.h\u0026gt;\nvoid main()\n{ int x;\ncin\u0026gt;\u0026gt;x;citim un numar\n}\n #include\u0026lt;fstream.h\u0026gt;\nvoid main()\n{ \nifstream f(”numere.in”); \nint x;\nf\u0026gt;\u0026gt;x;citim un numar din fisier\n}\n   \nFisierele de iesire, cele in care se vor afisa rezultatele NU trebuie create de noi, le va crea programul.\nSCRIEREA datelor\n Pe ecran\n in fisier\n   #include\u0026lt;iostream.h\u0026gt;\nvoid main()\n{ int x;\ncin\u0026gt;\u0026gt;x;\ncout\u0026lt;\u0026lt;x;\n}\n #include\u0026lt;fstream.h\u0026gt;\nvoid main()\n{ \nifstream f(”numere.in”); \nofstream g(”numere.out”); \nint x;\nf\u0026gt;\u0026gt;x; citim un numar din fisier\ng\u0026lt;\u0026lt;x;scriem in fisier\n}\n   \nATENTIE:\nNU mai utilizati clrscr() si getch() cand lucrati cu fisiere!\nFuncţii utile în prelucrarea fişierelor text\neof()– se utilizează pentru detectarea sfârşitului de fişier. Funcţia returnează 0 dacă valoarea curentă nu este sfârşitul de fişier şi 1 în caz contrar.\nf.close()– se utilizează pentru închiderea fişierului\nCITIREA datelor din fisier\n este cunoscut numarul n al valorilor\n cand nu este cunoscut numarul valorilor din fisier\n   Enunt: Se citesc n numere intregi , calculati suma lor si afisati aceasta suma in fisierul date.out.\n#include\u0026lt;fstream.h\u0026gt;\nvoid main()\n{ \nifstream f(”date.in”); \nofstream g(”date.out”); \nint x,s=0,n;\nf\u0026gt;\u0026gt;n;\nfor(i=1;i\u0026lt;=n;i++)\n{ f\u0026gt;\u0026gt;x;\ns=s+x;\n}\ng\u0026lt;\u0026lt;s;\nf.close();g.close();\n}\n Enunt: Se citesc toate numerele intregi din fisierul date.in, calculati suma lor si afisati aceasta suma in fisierul date.out.\nVARIANTA 1\n#include\u0026lt;fstream.h\u0026gt;\nvoid main()\n{ \nifstream f(”date.in”); \nofstream g(”date.out”); \nint x,s=0;\nwhile(f\u0026gt;\u0026gt;x)\ns=s+x;\ng\u0026lt;\u0026lt;s;\nf.close();g.close();\n}\nVARIANTA 2\n#include\u0026lt;fstream.h\u0026gt;void main()\n{\nifstream f(”date.in”);\nofstream g(”date.out”);\nint x,s=0;\nf\u0026gt;\u0026gt;x;\nwhile(!f.eof())\n{s=s+x;\nf\u0026gt;\u0026gt;x;}\ng\u0026lt;\u0026lt;s;\nf.close();g.close();\n}\n   \nEnunt: Se citesc n numere intregi , calculati suma lor si afisati aceasta suma in fisierul date.out.\nEnunt: Se citesc toate numerele intregi din fisierul date.in, calculati suma lor si afisati aceasta suma in fisierul date.out.\nAplicatii:\nProblema: Buchete\n(olimpiada locala de informatica 2003 – autor: Crstina Iordaiche)\nLa o florarie s-au primit n (n\u0026lt;=30000) fire de flori. Din fisierul buchete.in se citeste numarul n.\nFlorareasa doreste sa le aranjeze in vaze astfel incat:\n- toate vazele sa contina acelasi numar de flori\n- numarul florilor din vaza sa fie impar\nCerinta: Afisati in fisierul buchete.out, in cate moduri poate imparti florareasa cele n fire de flori.\nPentru fiecare caz afisati numarul de vaze necesare si cate flori va contine fiecare vaza.\nExemplu:\nn=9\n1 vaza a cate 9 flori\n3 vaze a cate 3 flori\n9 vaze cate 1 floare\n\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-\nFlorile se pot imparti in 3 moduri:\nProblema:Parola\n(Concursul National de informatica SATU MARE 2009 – autor: Crstina Iordaiche)\nLa un joc computerizat trecerea de la un nivel la altul se face prin intermediul unei parole in functie de punctajul obtinut de jucator, la nivelul anterior. Parola este un numar de maxim 9 cifre, cel mai mare posibil care se obtine luand in considerare o singura data toate cifrele ce fac parte din punctajul realizat de jucator. Citindu-se din fisierul parola.in punctajul P obtinut de jucator, afisati in fisierul parola.out, parola ce trebuie tastata pentru trecerea la nivelul urmator.\nExemplu:\nP= 41100 parola=410\nProbleme pentru pregatire in vederea participarii la olimpiada:http://olimpiada.info/oji2007/index.php?cid=arhiva\nhttp://campion.edu.ro/arhiva/index.php?page=problem\u0026amp;action=view\u0026amp;id=912\nhttp://campion.edu.ro/arhiva/index.php?page=problem\u0026amp;action=view\u0026amp;id=413\nhttp://campion.edu.ro/arhiva/index.php?page=problem\u0026amp;action=view\u0026amp;id=407   \n"
},
{
	"uri": "https://danielanicolae.com/programare/grafuri_neorientate/",
	"title": "Grafuri Neorientate",
	"tags": [],
	"description": "",
	"content": "  NOŢIUNI INTRODUCTIVE. DEFINIŢII Grafuri_neorientate.doc METODE DE REPREZENTARE Există mai multe moduri de reprezentare a grafurilor, alegerea făcându-se în funcţie de tipurile de operaţii care urmează să se efectueze:\n1. Matricea de adiacenţă: face o asociere între noduri şi indicii matricei. Este o matrice simentrică faţă de diagonala principală, cu nXn elemente, unde n este numărul de noduri.\naij= 1, dacă muchia [i,j] există\n0, dacă muchia [i,j] nu există\nObs.Numarul de valori “1” de pe linia “i” (sau de pe coloana “i”) reprezintă gradul nodului “i”.\n2. Matricea lanţurilor: este o matrice pătratică simetrică faţă de diagonala principală cu nXn elemente, unde n este numărul de noduri.\naij= 1, dacă lanţul de la i la j există\n0, dacă lanţul de la i la j nu există\nObs.matricea lanţurilor se obţine din matricea de adiacenţă prin aplicarea algoritmului lui Roy-Warshall. Se utilizează pentru a arăta dacă un graf este conex sau nu. Dacă are în matrice numai valori de 1, insemnă că graful este conex.\n3. Matricea costurilor: pentru reprezentarea grafurilor valorice. Este o matrice simentrică faţă de diagonala principală, cu nXn elemente, unde n este numărul de noduri.\naij= costul muchiei, dacă muchia [i,j] există\n0, dacă muchia [i,j] nu există\n∞, dacă este o problemă de minim (-∞, dacă este o problemă de maxim)\n4. Lista de adiacenţă reprezentată folosind alocarea dinamică se reţine pentru fiecare nod lista vecinilor\na) se foloseşte un vector care reţine adresa de început a listei vecinilor fiecărui nod\nb) se foloseşte o listă care reţine adresa de început a listei vecinilor fiecărui nod\n5. Lista de adiacenţă reprezentată folosind tablouri bidimensionale cu n+2m coloane şi două linii (n=numărul de noduri, m=numărul de muchii), pe prima linie se scriu numerele de la 1 la n+2m, iar pe a doua se reţine în coloanele de la 1 la n coloana în care apare primul vecin al său, iar pe coloanele de la n+1 la n+2m coloana pe care se află următorul vecin al nodului.\n6. Doi vectori: se reţine un capăt al muchiei într-un vector, iar celălalt capăt în al doilea vector. Lungimea vecorilor este egală cu numărul de muchii.\n7. Un vector de muchii: se defineşte tipul muchie (reţine capetele muchiei si eventual costul-pentru grafuri valorizate), apoi definim un vector de muchii care are atâtea componente câte muchii sunt\n8. lista de muchii: se defineşte tipul nod care reţine capetele muchiei şi eventual costul - pentru grafuri valorice.\nProbleme propuse: Fie G un graf neorientat, cu n vârfuri si m muchii, reprezentat prin matricea de adiacentă. Să se realizeze programe, în C/C++, care: a) afisează gradele tuturor vârfurilor; b) afisează vârfurile de grad par; c) afisează vârfurile izolate; d) afisează vârfurile terminale; e) verifică dacă graful are vârfuri izolate; t) verifică dacă graful are vârfuri terminale; g) verifică dacă graful are vârfuri interioare (nu sunt nici izolate nici terminale); h) verifică dacă graful are toate vârfurile izolate; i) verifică dacă graful are toate vârfurile interioare (nu sunt nici izolate nici terminale); j) afisează gradul unui vârf dat; k) afisează vecinii unui nod dat, vf; l) verifică dacă un vârf dat este terminal, izolat sau interior; m) afisează gradul cel mai mare si toate vârfurile care au acest grad n) afisează frecventa vârfurilor: izolate : n1 terminale : n2 interioare : n3 Aplicaţii cu grafuri neorientate  1. Din fişierul graf.in se citeşte de pe prima linie valorile n (numărul de noduri) şi m (numărul de muchii) ale unui graf neorientat G=(X,U). De pe următoarele m linii se citeşte lista muchiilor. Scrieţi funcţiile pentru:\na) Citirea grafului;\nb) Afişaţi matricea de adiacenţă a grafului;\nc) Afişaţi gradele tuturor nodurilor\nd) Afişaţi toate nodurile de grad maxim\ne) Afişaţi toate nodurile terminale\nf) Afişaţi toate nodurile izolate\n2. Din fişierul graf.in se citeşte de pe prima linie valorile n (numărul de noduri) şi m (numărul de muchii) ale unui graf neorientat G=(X,U). De pe următoarele m linii se citeşte lista muchiilor. Scrieţi funcţiile pentru:\na) Citirea grafului;\nb) Afişaţi listele de adiacenta;\nc) Afisati varfurile cu numar maxim de vecini;\nd) Afisati varfurile cu un singur vecin;\ne) Afisati varfurile fara vecini\n3. Din fişierul graf.in se citeşte de pe prima linie valorile n (numărul de noduri) şi m (numărul de muchii) ale unui graf neorientat G=(X,U). De pe următoarele m linii se citeşte lista muchiilor. Scrieţi funcţiile pentru:\na) Citirea grafului;\nb) Afişaţi matricea de adiacenţă a grafului;\nc) Afişaţi parcurgerile in latime din fiecare varf\n4. Din fişierul graf.in se citeşte de pe prima linie valorile n (numărul de noduri) şi m (numărul de muchii) ale unui graf neorientat G=(X,U). De pe următoarele m linii se citeşte lista muchiilor. Scrieţi funcţiile pentru:\na) Citirea grafului;\nb) Afişaţi matricea de adiacenţă a grafului;\nc)Afişaţi parcurgerile in adancime din fiecare varf\n5. Din fişierul graf.in se citeşte de pe prima linie valorile n (numărul de noduri) şi m (numărul de muchii) ale unui graf neorientat G=(X,U). De pe următoarele m linii se citeşte lista muchiilor. Scrieţi funcţiile pentru:\na) Citirea grafului;\nb) Afişaţi matricea de adiacenţă a grafului;\nc) Afişaţi matricea lanţurilor\n\n\u0026lt;/div\u0026gt;   \n"
},
{
	"uri": "https://danielanicolae.com/programare/grafuri_orientate/",
	"title": "Grafuri Orientate",
	"tags": [],
	"description": "",
	"content": "  NOŢIUNI INTRODUCTIVE. DEFINIŢII Grafuri_orientate.docx\nGRAFURI_ORIENTATE.pdf   \n"
},
{
	"uri": "https://danielanicolae.com/programare/greedy/",
	"title": "Greedy",
	"tags": [],
	"description": "",
	"content": "  Metoda Greedy\n“De alegerea strategiei depinde atât timpul de rezolvare cât și calitatea soluției gasite“\n1. Descrierea metodei Se dă o mulţime A cu n elemente şi se cere să se determine o submulţime a sa(B) care satisface anumite restricţii. Această submulţime se numeşte soluţie posibilă. Se cere să se determine o soluţie posibilă care fie să maximizeze fie să minimizeze o anumită funcţie obiectiv dată. Această soluţie posibilă se numeşte soluţie optimă.\nMetoda Greedy lucrează în paşi astfel:\nse iniţializează mulţimea soluţiilor (B) cu mulţimea vidăse alege un anumit element x din  Ase verifică dacă elementul ales poate fi adăugat la mulţimea soluţiilor, dacă da atunci va fi adăugatprocedeul continuă astfel, repetitiv, cu pasul 2 până când au fost determinate toate elementele din mulţimea soluţiilorObservaţie. Metoda Greedy nu caută să determine toate soluţiile posibile ( care ar putea fi prea numeroase) şi apoi să aleagă din ele pe cea optimă, ci caută să introducă direct un element x în soluţia optimă.\n2. Ideea metodei: La fiecare pas se alege un element care face solutia partiala cat mai buna. Se presupune ca facand mereu alegerea cea mai buna la moment, avem sansa (dar nu certitudinea) obtinerii solutiei optime, in final.Algoritmii Greedy sunt foarte eficienți, dar nu conduc în mod necesar la o soluție optimă. Şi nici nu este posibilă formularea unui criteriu general conform căruia să putem stabili exact dacă metoda Greedy rezolvă sau nu o anumită problemă de optimizare. Din acest motiv, orice algoritm Greedy trebuie însoțit de o demonstrație a corectitudinii sale . Demonstrația faptului că o anumită problemă are proprietatea alegerii Greedy se face de obicei prin inducție matematică\n\nO întrebare firească este aceea dacă algoritmul Greedy duce totdeauna la soluţie optimă? Evident că nu Sunt situaţii când soluţia găsită nu este optimă. Mai mult, pentru cele mai multe din probleme nu se cunosc algoritmi Greedy de rezolvare. Spre deosebire de Backtracking, algoritmul Greedy nu permite atunci când s-a oservat că nu se poate ajunge la soluţie pentru o anumită secvenţă de elemente, revenirea înapoi, pe nivelele anterioare. Pentru problemele care nu duc la soluţia optimă este necesar să se caute soluţii, chiar dacă nu optime, dar cât mai apropiate de acestea.\nÎntre metoda Greedy şi metoda Backtracking putem enumera următoarele diferenţe:\n• ambele tehnici oferă soluţii sub formă de vector\n• tehnica Backtracking oferă toate soluţiile problemei, în timp ce Greedy oferă o singură soluţie\n• tehnica Greedy nu dispune de mecanismul întoarcerii, specific tehnicii Backtracking\nAlgoritmi clasici:Problema rucsacului. Un hot are la dispozitie un rucsac cu care poate transporta o greutate maxima Gmax. Hotul are de ales din n obiecte si intentioneaza sa obtina un castig maxim in urma singurului transport pe care il poate face. Cunoscand, pentru fiecare obiect i greutatea Gi si castigul Ci pe care hotul l-ar obtine transportand obiectul respectiv in intregime, scrieti un program care sa determine o incarcare optima a rucsacului.\nrucsac.cpp\nProblema platii unui salariu. Sa se plateasca un salariu dat cu numar minim de monezi, daca se cunosc tipurile de monezi existente. Monedele sunt in numar nelimitat (variante cu/fara atingerea solutiei optime).\nCazul 1.Se atinge solutia optima.\nSuma= 360; Monedele sunt 100, 50, 20,10,3\n360=3*100+1*50+1*10+0*3\nCazul 2.\nNu se atinge solutia optima\nSuma= 365; Monedele sunt 100, 50, 20,10,3\n365=3*100+1*50+1*10+1*3 NEPLATIT 2\nOptim ar fi fost:\n365=3*100+1*50+0*10+5*3\n#include\u0026lt;iostream\u0026gt;\nusing namespace std;\nint n,i,aux,ok,s,a[100], nr[100];\nmain()\n{\ncout\u0026lt;\u0026lt;\u0026quot;Suma=\u0026quot;;cin\u0026gt;\u0026gt;s;\ncout\u0026lt;\u0026lt;\u0026quot;Numarul de bancnote:\u0026quot;;cin\u0026gt;\u0026gt;n;\nfor(i=1;i\u0026lt;=n;i++)\n{\ncout\u0026lt;\u0026lt;\u0026quot;a[\u0026quot;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026quot;]=\u0026quot;;cin\u0026gt;\u0026gt;a[i];\nnr[i]=i;\n}\ndo\n{\nok=1;\nfor(i=1;i\u0026lt;=n-1;i++)\nif(a[nr[i]]\u0026lt;a[nr[i+1]])\n{\naux=nr[i];\nnr[i]=nr[i+1];\nnr[i+1]=aux;\nok=0;\n}\n}\nwhile(ok==0);\nfor(i=1;i\u0026lt;=n;i++)\ncout\u0026lt;\u0026lt;nr[i]\u0026lt;\u0026lt;\u0026quot; \u0026quot;;\ni=1;\ncout\u0026lt;\u0026lt;s\u0026lt;\u0026lt;endl;\ndo\n{\nif(s/a[nr[i]]\u0026gt;0)\n{cout\u0026lt;\u0026lt;s/a[nr[i]]\u0026lt;\u0026lt;\u0026quot; bancnote cu valoarea \u0026quot;\u0026lt;\u0026lt;a[nr[i]]\u0026lt;\u0026lt;endl;\ns=s%a[nr[i]];}\ni++;\n}\nwhile(i\u0026lt;=n);\n}\nProblema spectacolelor\nManagerul artistic al unui festival trebuie să selecteze o mulțime cât mai amplă de spectacole ce pot fi jucate în singura sală pe care o are la dispoziție. Ştiind că i s-au propus n≤100 spectacole şi pentru fiecare spectacol i i-a fost anunțat intervalul în care se poate desfăşura [si, fi) (si reprezintă ora şi minutul de început, iar fi ora şi minutul de final al spectacolului i) scrieți un program care să permită spectatorilor vizionarea unui număr cât mai mare de spectacole. De exemplu, dacă vom citi n=5 şi următorii timpi:\n12 30 16 30\n15 0 18 0\n10 0 18 30\n18 0 20 45\n12 15 13 0\nSpectacolele selectate sunt: 5 2 4.\nSoluție\nOrdonăm spectacolele crescător după ora de final. Selectăm inițial primul spectacol (deci cel care se termină cel mai devreme). La fiecare pas selectăm primul spectacol neselectat, care nu se suprapune cu cele deja selectate (deci care începe după ce se termină ultimul spectacol selectat).\n#include \u0026lt;iostream.h\u0026gt;\nint inceput[100], sfarsit[100], nr[100];\nint main()\n{int n, i, h, m, ok, ultim, aux;\ncout \u0026lt;\u0026lt; \u0026quot;n= \u0026quot;; cin \u0026gt;\u0026gt; n; citire\ncout\u0026lt;\u0026lt;\u0026quot;Introduceti inceputul si sfarsitul spectacolelor\u0026quot;;\nfor (i=1; i\u0026lt;=n; i++)\n{nr[i]=i; \ntransform timpul in minute\ncin\u0026gt;\u0026gt;h\u0026gt;\u0026gt;m; inceput[i]=h*60+m;\ncin\u0026gt;\u0026gt;h\u0026gt;\u0026gt;m; sfarsit[i]=h*60+m;} ordonez spectacolele crescator dupa ora de final\ndo\n{ok=1;\nfor (i=1; i\u0026lt;n; i++)\nif (sfarsit[nr[i]]\u0026gt;sfarsit[nr[i+1]])\n{aux=nr[i];nr[i]=nr[i+1];nr[i+1]=aux; ok=0;}\n}\nwhile (ok==0);\ncout \u0026lt;\u0026lt; \u0026quot;Spectacolele selectate sunt:\u0026quot;\u0026lt;\u0026lt;nr[1]\u0026lt;\u0026lt;\u0026rsquo; \u0026lsquo;;\nultim=1;\nfor ( i=2; i\u0026lt;=n; i++)\nif (inceput[nr[i]]\u0026gt;=sfarsit[nr[ultim]])\n{cout \u0026lt;\u0026lt;nr[i]\u0026lt;\u0026lt;\u0026rsquo; \u0026lsquo;; ultim=i;}\ncout\u0026lt;\u0026lt;endl;\nreturn 0;}\nProblema comis-voiajorului. \nSe cunosc distantele dintre mai multe orase. Un comis-voiajor pleaca dintr-un oras si doreste sa se intoarca in acelasi oras, dupa ce a vizitat fiecare din celelalte orase exact o data. Problema este de a minimiza lungimea drumului parcurs. (Indicatie. La fiecare pas se alege orasul nou, cel mai apropiat).\ncomis.cpp\nProblema partitiilor de numere prime// Se da un sir de numere naturale citite pe rand pana la intalnirea numarului 0.Sa se determine un grup maxim de elemente ale sirului cu proprietatea ca elementele sunt numerele prime iar suma lor e egala cu cel mult un numar m dat .\npart.cpp   \n"
},
{
	"uri": "https://danielanicolae.com/programare/html/",
	"title": "HTML",
	"tags": [],
	"description": "",
	"content": "  Planificarea site-ului Planificarea site-ului contine urmatoarele etape:\nStabilirea audienţeiStabilirea scopuluiDefinirea obiectivelorColectarea informaţiilor despre subiectul prezentatStabilirea specificaţiilorStabilirea modului de prezentareStabilirea audienţei Pentru a crea un site de calitate şi o comunicare eficientă a informaţiilor, o etapă deosebit de importantă este definirea audienţei site-ului. Audienţa reprezintă publicul căruia i se adresează site-ul. Stabilirea audienţei site-ului dumneavoastră este esenţială deoarece contribuie la definirea conţinutului paginilor, precum şi a organizării şi aspectului său. Un site Web creat pe baza unor informaţii precise asupra audienţei sale actuale şi viitoare are mult mai multe şanse de succes decât unul care nu se adresează unui public specific.\nDe asemenea aici se stabileste daca se doreste ca site-ul sa se adreseze si clientilor internationali adica sa fie facut in mai multe limbi. Scopul Stabilirea scopului site-ului este etapa în care trebuie să răspundeţi la întrebarea \u0026quot;de ce?\u0026quot;. De ce doriţi să creaţi acest site? Definiţia scopului site-ului reprezintă tema conducătoare în procesul de construire a acestuia. Un site fără un scop clar şi bine definit lansează un mesaj neconvingător şi ceţos. Vizitatorul se va întreba, fără îndoială, \u0026quot;La ce serveşte acest site?\u0026quot; şi se va grăbi să-l părăsească.\nObiectivele După ce aţi stabilit audienţa site-ului, care sunt informaţiile privitoare la publicul ţintă, precum şi scopul său, pasul următor constă în combinarea tuturor acestor informaţii şi formularea unor obiective specifice ale site-ului dumneavoastră. Obiectivele reprezintă o detaliere a scopului general al site-ului, conţinând informaţiile specifice care vor conduce la îndeplinirea scopului pentru care a fost creat site-ul. De exemplu, dacă scopul unui site este \u0026quot;să ofere informaţii despre oraşul ZZZ\u0026quot; , acesta poate fi dus la îndeplinire prin intermediul unor obiective specifice şi variate cum ar fi: informaţii despre aşezarea geografică a oraşului, despre dezvoltarea economică, despre viaţa culturală, obiective turistice, etc. Cu alte cuvinte, în vreme ce scopul site-ului comunică ce aveţi de gând să faceţi, obiectivele comunică ce informaţii veţi oferi pentru a vă îndeplini scopul propus.\nColectarea informaţiilor despre subiect Informaţiile referitoare la subiectul site-ului includ atât informaţiile on-line cât şi sursele clasice de informaţii. În această etapă veţi colecta nu numai informaţii legate de subiectul site-ului care vor fi prezentate utilizatorului ci şi informaţiile şi cunoştinţele de care aveţi nevoie pentru realizarea site-ului.\nSpecificaţiile Stabilirea specificaţiilor pentru un site reprezintă o detaliere a obiectivelor sale şi definirea unor cerinţe sau a unor restricţii. Specificaţiile descriu în detaliu ce informaţii vor fi oferite în paginile site-ului şi cum vor fi ele prezentate. De exemplu, dacă unul dintre obiectivele unui site este \u0026quot;furnizarea de legături către surse bibliografice referitoare la subiect\u0026quot; , atunci specificaţiile vor preciza care sunt aceste surse bibliografice, care sunt adresele lor URL, câte astfel de adrese vor fi incluse într-o pagină, etc.\nModul de prezentare Planificarea modului de prezentare implică o serie de decizii care vor servi drept puncte de reper în etapa de construire efectivă a site-ului. Această etapă poate include:\nCrearea unor template-uri pentru siteCrearea unor mostre de documente HTML, imagini hartă, sau formulareEşalonarea în timp a etapelor de creare a site-ului\n LECTIA 1\n lectia1.doc\n   LECTIA 2\n lectia 2.doc\n   LECTIA 3\n lectia3.doc\n   LECTIA 4\n lectia 4.doc\n   LECTIA 5\n lectia 5.doc\n   LECTIA 6\n lectia 6.doc\n   LECTIA 7\n lectia 7.doc\n   LECTIA 8\n lectia 8.doc\n   LECTIA 9\n lectia 9.doc\n   EXEMPLU DE SITE HTML site_exemplu_html.zip   \n"
},
{
	"uri": "https://danielanicolae.com/programare/infoscience/",
	"title": "InfoScience",
	"tags": [],
	"description": "",
	"content": "  structura repetitiva.ppt\nhttp://infoscience.3x.ro/c++.html\nAlgoritmi\n//Algoritmi. Introducere//\n//Notiunile cu care opereaza algoritmii//\nOperatiile de baza pe care le efectueaza un algoritm \n//Principiile programarii structurate//\n//Teorema lui Bohm si Jacopini//\n//Aplicatii propuse//\nLimbajul C++\nElemente de baza ale limbajului\n1 Structura programelor C++\n2 Elemente lexicale\n3 Date in C++\n4 Operatori\n5 Implementarea structurilor de control Instructiunea vida, if si switch Instructiuni repetitive\n6 Siruri de caractere\n7 Tablouri unuidimensionale (vectori)\n8 Subprograme\n8.1 Definitia. Declarare. Apel 8.2 Functii fara tip.Aplicatii\n8.3 Functii cu tip.Aplicatii 8.4 Transmiterea parametrilor 8.4 Functii. Probleme propuse 8.5 Fisiere header definite de programator\n9 //Pointeri//\n10 //Alocarea dinamica amemoriei//\na) //Structuri dinamice de date//  b) Liste liniare simplu inlantuite. Creare. Parcurgere c) Liste liniare simplu inlantuite. Inserare si Stergere d) Ordonarea listelor\ne) Structura de date de tip coada f) Structura de tip stiva g) Liste liniare dublu inlantuite. h) Liste circulare  i) Structuri dinamice de date. aplicatii\nListe liniare simplu inlantuite\n//Probleme propuse//\n11 //Recursivitate//\na) //Aplicatii recursivitate// b) Recursivitate indirecta c) Aplicatii ale recursivitatii. Fractali\n12 Divide et Impera a)Aplicatii D\u0026amp; I: Sortarea rapida (Quick Sort) b)Sortarea prin interclasare: (MergeSort)\nc) Turnurile din Hanoi \nd)Divide et Impera. Probleme propuse \nGrafuri neorientatea) Terminologie\u0026gt;  b) Reprezentarea grafurilor neorientate:matricea de adiacenta\u0026gt;  c) Reprezentarea grafurilor neorientate:: liste de adiacented) parcurgerea grafurilorparcurgerea in latime\u0026gt;  parcurgerea in adancime\u0026gt;  e) matricea drumurilor\u0026gt;  f) Conexitate\u0026gt;  g) matricea ponderilor\u0026gt;  h) algoritmul lui Roy Floydi) graf hamiltonian\u0026gt;  j) graf eulerianGrafuri neorientate. Probleme propuse\nGrafuri orientate\na) Terminologie\nb) Matricea de adiacenta \nc) Liste de adiacenta \nd) Parcurgere in latime \ne) Parcurgere in adancime \nf) Componente tare conexe \ng) Algoritmul lui Djikstra\nh) Algoritmul lui Lee\n//Probleme propuse//\nArbori si arborescente\na)Arbori oarecare\nb)Arborescente\nc)Arbori binari\nd)Parcurgerea arborilor binari\ne)Arbori de cautare\nf)Stergerea intr-un arbore binar de cautare\ng) Arborele partial de cost minim\n//Recapitulare pt teza clasa a XI-a////Teza clasa a XI-a. Semestrul 1//Aplicatie recapitulativa structuri de date\nTehnici de programare\n1 Tehnica Backtracking\nPermutari\nbacktracking recursiv\n//Probleme propuse//\n2 Backtracking in plan \nBacktracking in plan. Probleme \n3 Tehnica Greedy\n4 Programare dinamica\n//Centrul de excelenta.Probleme propuse//\nProgramare orientata pe obiecte\n1. Introducere\n2. Definirea claselor\n3. Constructori si destructori\n4. Supraincarcarea operatorilor\n5. Mostenirea\n6. Metode virtuale\n//Probleme propuse//\nhttp://infoscience.3x.ro/c++/1001probleme.htm\nRecapitulare pentru teza clasa a XI-a\nArbori binari\nProbleme recapitulative\nTehnici de programare-probleme\nFunctii pentru modulul grafic\nhttp://www.worldit.info/articole/instructiunile-limbajului-c/   \n"
},
{
	"uri": "https://danielanicolae.com/programare/infoscience_algoritmi/",
	"title": "InfoScience - Algoritmi",
	"tags": [],
	"description": "",
	"content": "  DRUMURI MINIME SI MAXIME IN GRAFURIConsiderăm un graf orientat G=(X,U) cu n noduri, în care fiecărui arc îi este asociat un număr întreg numit cost. Semnificaţia acestui cost poate fi foarte variată, în funcţie de domeniul pe care îl descrie graful. De exemplu, dacă graful reprezintă harta unui oraş în care arcele sunt străzile, iar nodurile sunt intersecţiile dintre stăyi, atunci putem vorbi despre costul deplasării unui automobil între două intersecţii, de-a lungul unei străzi. Acesta s-ar putea măsura în cantitatea de benzină consumată, calculată prin prisma lungimii străzii în m sau in km.MATRICEA COSTURILORPentru evidenţierea costurilor tuturor arcelor unui graf cu n noduri se poate defini o matrice a, cu n linii *n coloane.există două forme ale acestei matrici:Forma a): Fiecare element a[i,j] poate fi:-c, dacă există un arc de cost c\u0026gt;0 între nodurile i şi j;-0, dacă i=j;-+infinit, dacă nu există arc între nodurile i şi j.Forma b): Este absolut similară, cu singura deosebire că în loc de +infinit avem -infinit.Forma a)se foloseşte pentru determinarea drumurilor de cost minim între două noduri, iar forma b) este utilizată în aflarea drumurilor de cost maxim.Dacă dorim să citim matricea costurilor, evident că nu putem introduce de la tastatură “+infinit”! În loc de “+infinit” vom da un numar de la tastatură foarte mare.Problema determinării drumului minim/ maxim între două noduri face obiectul algoritmului următor.Algoritmul Roy-FloydSe consideră un graf orientat cu n noduri, pentru care se dă matricea costurilor în forma a). Se cere ca, pentru fiecare pereche de noduri (i, j), să se tipărească costul drumului minim de la i la j.Plecăm de la următoarea idee: dacă drumul minim între două noduri oarecare i şi j trece printr-un nod k, atunci drumurile de la i la k şi de la k la j sunt la rândul lor minime. Pentru fiecare pereche de noduri (i, j ), cu i, j apartinand multimii {1,2,…,n}, procedăm astfel:\nDăm lui k pe rând valorile 1,2,…,n, pentru ca nodul k despre care vorbeam mai sus poate fi, cel puţin teoretic, orice nod al grafului. Pentru fiecare k: dacă suma dintre costul drumului de la i la k şi costul drumului de la k la j este mai mică decât costul drumului de la i la j {a[i, k]+a[k, j]\u0026lt;a[i, j]}, atunci drumul iniţial de la i la j este înlocuit cu drumul indirect i-k-j.această înlocuire fireşte că se va opera ca atare în matrocea costurilor: {a[i, j]:=a[i, k]+a[k, j]}.Prezentăm în continuare procedura generare care conţine algoritmul descris:Procedure generare;var i,j,k:integer;beginfor k:=1 to n dofor i:=1 to n dofor j:=1 to n doif a[i, k]+a[k, j]\u0026lt;a[i, j] then a[i, j]:=a[i, k]+a[k, j];end;\nObservatii Drumurile minime între toate nodurile se regăsesc la sfarsitul algoritmului tot în matricea costurilor, care a suferit n trasformări, pentru k=1,2,…,n. Unele elemente pot fi +infinit, iar pentru simularea lui +infinit am spus că se introduce un număr întreg foarte mare. Prin adunări repetate a două numere întregi foarte mari putem ajunge la un rezultat care depăşeşte cea mai mare valoare posibilă de tipul integer. De aceea, recomandăm ca elementele matricei costurilor să fie de tipul longint. În cazul în care problema cerea pentru fiecare pereche de noduri (i, j) costul drumului maxim, modificările necesare ar fi minore: - se foloseşte forma b) a matricei costurilor;- condiţia testată în linia if devine “a[i, k]+a[k, j]\u0026lt;a[i, j]”Algoritmul Roy Floyd (determină costul minim al drumului dintre oricare două vârfuri x, y, precum şi un astfel de drum.)\nhttp://www.liis.ro/~ema/proiecte/soft/2005/drum/%2B%20prezentare/flash/cod_rf.swf\n   \n"
},
{
	"uri": "https://danielanicolae.com/programare/liste_liniare/",
	"title": "Liste Liniare",
	"tags": [],
	"description": "",
	"content": "   Structurile dinamice de date sunt date structurate ale caror componente se aloca in mod dinamic.\nAvantajul alocarii dinamice fata de alocarea acelorasi structuri de date in mod static (in segmentul de date) sau volatil (in segmentul de stiva) sunt: - memorie suplimentara pentru programe - posibilitatea de a utiliza aceasta memorie Alocarea dinamica a componentelor structurii impune un mecanism prin care o noua componenta aparuta este legata in succesiune logica de corpul structurii deja format pana atunci. Rezulta ca fiecare componenta, pe langa informatia propriu-zisa pe care o detine, trebuie sa contina si o informatie de legatura cu componenta cu care se leaga logic in succesiune. Aceasta informatie de legatura va fi adresa componentei spre care se realizeaza succesiunea logica, iar mecanismul se mai numeste si alocare inlantuita dupa adrese. In HEAP, structura respectiva va avea zone alocate componentelor sale in locurile gasite disponibile, care nu se succed intotdeauna in ordinea in care este realizata inlantuirea logica. In functie de tipul inlantuirii realizate intre componente, exista urmatoarele tipuri de organizari: - structuri liniare (de exeplu o lista care prelucreaza elevii care se inscriu la un examen) o liste simplu inlantuite (liniare si circulare) o liste dublu inlantuite (liniare si circulare) - structuri arborescente (de exemplu reteaua ierarhica a angajatilor dintr-o firma) - structuri retea (de exemplu o retea de orase care schimba materiale, combustibili etc) O listã înlãntuitã este o structurã dinamicã, flexibilã, care se poate adapta cerintelor aplicatiei, fãrã ca utilizatorul sã fie preocupat de posibilitatea depãsirii unei dimensiuni estimate initial . Avantajul folosirii listelor consta in gestionarea dinamica a memoriei. Alocarea sau eliberarea nodurilor se face dinamic, la fiecare inserare respectiv stergere,ceea ce face ca nodurile listei sa fie plasate dispersat in memorie (in cazul vectorilor – structuri de date omogene alocate static, zona de memorie folosita este contigua). Legatura dintre nodurile invecinate trebuie facuta logic explicit de catre programator, prin pastrarea informatiilor de legatura in fiecare nod (pe langa valoarea utila). \nliste simplu inlantuite\nliste dublu inlantuite \n PROGRAME SURSA   PROBLEME PROPUSE    \n creare.cpp\n liste_simplu_inlantuite1.doc\n   liste_simplu_inlantuite.cxx\n liste_simplu_inlantuite2.doc\n   liste_dublu.cpp\n \n   GRILE Grile_alocare_dinamica_C++.doc \u0026lt;/div\u0026gt;   \n"
},
{
	"uri": "https://danielanicolae.com/programare/mate_bac/",
	"title": "Mate Bacalaureat",
	"tags": [],
	"description": "",
	"content": "  DomnulTudor - MATE BAC   modul_parte_putere_radical_ecuatii_si_inecuatii_teorie.doc TEORIE MATE LICEU STAN ADRIAN.pdf\ninductieteorie.doc inductieprobleme.doc\n0_progresii_aritmetice_si_geometrice.doc puterisiradicalibun.PDF\nmodulubun.PDF inegalitatibun.PDF\nSite-uri utile math-pdr.com\nmatematica.noads.biz\nmatepe.net\nmateinfo.ro/formule-matematica   \n"
},
{
	"uri": "https://danielanicolae.com/programare/metode_de_sortare/",
	"title": "Metode de Sortare",
	"tags": [],
	"description": "",
	"content": "  METODE SI TEHNICI DE SORTARE A UNUI VECTOR\n(SORTARE IN ORDINE CRESCATOARE)\n\n1. METODA DE SORTARE PRIN INTERSCHIMBAREAceasta metoda consta in parcurgerea sirului utilizand doi contori (i si j) . Fiecare element a[i]se va compara cu toate elementele din dreapta sa, elemente de forma a[j],cu j=i+1,nDaca a[i]\u0026gt;a[j] atunci cele doua component e se vor interschimbaObs: aceasta metoda nu este eficienta deoarece daca sirul ar fi de la inceput sortat sirul tot se parcurge realizand n(n-1)/2 comparatii ALGORITMUL:Citeste n\nCiteste sirul a cu n elemente\nPentru i=1,n-1 executa\nPentru j=i+1,n executa\nDaca a[i]\u0026gt;a[j] atunci\n{\naux=a[i]a[i]=a[j]a[j]=aux\n}\nAfisare sir a\n2. SORTAREA PRIN METODA BULELOR\nMetoda consta in parcurgerea sirului ori de cate ori este nevoie pana cand sirul devine sortat sau cat timp sirul nu este sortatInainte de parcurgerea sirului se presupune de fiecare daca ca sirul ar fi sortat utilizand o variabila logicaLa fiecare iteratie sirul se va parcurge pana la ultima componenta care nu este sortata .Parcurgerea sirului consta in compararea de fiecare data a doua componente de pe pozitii consecutive, de forma a[i] si a[i+1]Daca a[i]\u0026gt;a[i+1] cele doua componente se vor interschimbaDaca la o parcurgere a sirului exista cel putin o interschimbare inseamna ca sirul inca nu este sigur sortat si se reia parcurgerea siruluiDaca la o parcurgere a sirului nu exista nicio interschimbare atunci cu siguranta sirul este sortat Obs : metoda are rolul de a transporta , la fiecare parcurgere a sirului, valoare maxima dintre componente nesortate si de a o plasa pe pozitia finala in sirul sortat . ALGORITMUL\nCiteste n\nCiteste sirul a cu n elemente\nexecuta\n{ok=1\n// se presupune ca sirul este sortat\nPentru i=1,n-1 executa\nDaca a[i]\u0026gt;a[i+1] atunci\n{aux=a[i]\na[i]=a[i+1]a[i+1]=auxok=0\n}}\ncat timp (ok==0)\nSe afiseaza sirul a\n3. METODA DE SORTARE PRIN NUMARARE\nEste o metoda ineficienta ca spatiu de memorie deoarece utilizeaza 3 siruri astfel : sirul a cel care trebuie sortat, sirul b cel in care se vor plasa elementele sortate si respectiv sirul nr avand semnificatia ca nr[i]= numarul elementelor sirului a care sunt mai mici decat a[i]Pentru formarea sirului nr se parcurge sirul cu doua foruri avand variabilele contor i si respectiv j Fiecare element a[i] se compara cu toate elementele din dreapta sa, elemente de forma a[j] cu j=i+1,nDaca a[i]\u0026gt;a[j] creste nr[i] cu o unitate , in caz contrar creste nr[j] cu o unitateDupa formarea sirului nr , orice componenta nr[i], la care se aduna o unitate reprezinta pozitia elementului a[i] in sirul sortatSirul sortat b se formeaza dupa urmatoarea regula : b[nr[i]+1]=a[i], unde i=1,nALGORITMULCiteste n\nCiteste sirul a cu n elemente\nPentru i=1,n executa\nPentru j=i+1, n executa\nDaca a[i]\u0026gt;a[j] atunci nr[i]=nr[i]+1\nAltfel nr[j]=nr[j]+1\nPentru i=1,n executa\nb[nr[i]+1]=a[i]\nAfiseaza sirul b\n4. METODA DE SORTARE PRIN SELECTIE DIRECTA\nMetoda consta in parcurgerea sirului de la prima componenta pana la componenta n-1 inclusivLa pasul i componentele a[1],a[2],\u0026hellip;,a[i-1] sunt deja sortate . La pasul i se determina valoarea minima respectiv pozitia elementului minim dintrea componentele a[i],a[i+1],\u0026hellip;,a[n] . Fie p pozitia elementului minim . Daca p este diferit de i atunci componentele a[i] si a[p] se vor interschimba ALGORITMUL\nCiteste n\nCiteste sirul a cu n componente\nPentru i=1,n-1 executa\n{\nmin=a[i]\np=i\nPentru j=i+1,n executa\nDaca a[j]\u0026lt;min atunci\n{min=a[j]\np=j\n}\nDaca p!=i atunci\n{\na[p]=a[i]\na[i]=min\n}\n}\nAfiseaza sirul a\n5. METODA DE SORTARE PRIN INSERTIE DIRECTA\nAceasta metoda consta in parcurgerea sirului incepand cu a doua componenta pana la finalLa pasul i elementele a[1],a[2],..,a[i-1] sunt deja sortate si trebuie sa plasam elementul a[i] printre elementele deja sortate Pentru a plasa elementul a[i] vom parcurge urmatorii pasi :i) Se retine a[i] intr-o variabila temporara tii) Indicele j parcurge in ordine inversa elementele deja sortateiii) Cat timp a[j]\u0026gt;t si j\u0026gt;0 elementul a[j] se deplaseaza la dreapta cu o unitate, iar j descreste cu o unitateiv) In final t se va pozitiona pe urmatoare componenta pentru care nu a mai fost adevarata conditia : a[j+1]=tALGORITMUL\nCiteste n\nCiteste sirul a cu n elemente\nPentru i=2,n executa\n{\nt=a[i]j=i-1\nCat timp a[j]\u0026gt;t si j\u0026gt;0 executa\n{\na[j+1]=a[j]j=j-1\n}\na[j+1]=t\n}\nAfiseaza sirul a   \n"
},
{
	"uri": "https://danielanicolae.com/programare/metode_tehnici_clasice_programare/",
	"title": "Metode si Tehnici Clasice de Programare",
	"tags": [],
	"description": "",
	"content": "  POSTLICEALA ANUL I Calificarea: ANALIST PROGRAMATOR MODULUL VIII-Metode şi tehnici clasice de programare METODE ŞI TEHNICI CLASICE DE PROGRAMARE_I.doc\nMETODE ŞI TEHNICI CLASICE DE PROGRAMARE_II.doc\nAlte materiale de invatare avizate, elaborate prin proiectul “ Învățământul profesional și tehnic în domeniul TIC”POSDRU/1/1.1/S/4/994 găsiți la adresa http://cndiptfsetic.tvet.ro   \n"
},
{
	"uri": "https://danielanicolae.com/programare/oracle/",
	"title": "Oracle",
	"tags": [],
	"description": "",
	"content": "  Comanda UPDATE Comanda UPDATEeste folosită pentru a modifica valorile datelor existente în tabele. \nSintaxa uzuală a comenzii UPDATE prezintă următoarele variante:\n1)\nUPDATE tabel \nSET coloana1 = expresie1,\ncoloana2 = expresie2, \u0026hellip;\n[WHERE condiţie];\n2)\nUPDATE tabel \nSET coloana1 = expresie1,\ncoloana2 = expresie2, \u0026hellip;\nFROM tabele_cuplate\n[WHERE condiţie];\nClauza FROM este o extensie specifica SQL Server, inexistenta în standardul SQL92 . Prin această extensie se poate specifica o cuplare de mai multe tabele care se poate folosi în locul unei fraze Select imbricată în clauza WHERE. Sunt acceptate toate tipurile de asocieri (Inner, Left, Right, Full) sunt acceptate şi reyultate obţinute din fraze Select.\nComanda UPDATE modifică valorile înregistrărilor în funcţie de condiţia clauzei WHERE. În lipsa clauzei WHERE, vor fi actualizate toate înregistrările din tabelul dat. Expresia furnizată ca valoare nouă a unei coloane poate cuprinde valorile curente ale câmpurilor din înregistrarea care este actualizată.\nExemple:\nupdatetProduse setpret=pret1.1 \nupdatetProduse setpret=pret0.95 where categoria = ‘Alimentare’\nupdatetProduse setpret=pret*0.95 where codProd in (select codProd from tProduse where categoria = ‘Alimentare’)\nupdatetProduse setpret=CASE\nWhen pret\u0026lt;100 then pret*1.1\nWhen pret\u0026lt;200 then pret*1.08\nWhen pret\u0026lt;300 then pret*1.05\nElse pret1.03\nEND\nPresupunând că avem un tabel tModiPret cu structura:\ncreatetabletModiPret\n(codProd char(10)primarykey,\nprocent float\n)\nce conţine procentele diferentiate de modificare a preturilor anumitor produse,\nPentru a modifica datele din tabela tProduse pe baza datelor din tabela tModiPretse poate folosi următoarea comandă care conţine tabele corelate\n\nupdatetProduse setpret=pret1.1 \nfrom\ntProduse Ainner join tModiPret Bon A.codProd=B.codProd\nsau\nUPDATEtProduse \nSETpret=pret*(1+(SELECTprocent \nFROMtModiPret A\nWHEREA.codP=tProduse.codProd)/100)\nWHEREcodProd IN (SELECTcodProd FROMtModiPret);\nObs. Daca nu includem conditia\nWHEREcodProd IN (SELECTcodProd FROMtModiPret)\natunci (SELECTprocent \nFROMtModiPret A\nWHEREA.codP=tProduse.codProd)/100)\nVa returna null pentru valorile din coloana codProd ce nu se gasesc în tModiPret şi prin urmare pentru aceste coduri, pret va fi setat cu null\nDacă tabelul de actualizat este implicat în diverse legături cu alte tabele ca partea unu a unei legături unu la multi şi opţiunea update cascading este activată atunci orice modificare în cămpul de legatură va fi propagată şi în tabelele secundare corelate\nALTERTABLEtDetaliiBon ADDFOREIGNKEY(CodProd)\nREFERENCEStProduse (CodProd)onupdatecascade\nupdatetProduse setcodProd =\u0026lsquo;p101\u0026rsquo;wherecodProd=\u0026lsquo;p1\u0026rsquo;\nva produce automat modificarea în tabelul tDetaliiBon din codProd=\u0026lsquo;p1\u0026rsquo; în codProd =\u0026lsquo;p101\u0026rsquo;\nComanda DELETE Comanda DELETErealizează ştergerea înregistrărilor dintr-un tabel în funcţie de anumite condiţii.\nComanda DELETE şterge numai înregistrări din tabel nu şi tabelul. Pentru a şterge un tabel se foloseşte comanda DROPTABLE.\nSintaxa uzuală a comenzii DELETE prezintă următoarele variante:\n1)\nDELETE [FROM] tabel\n[WHERE condiţie];\n2)\nDELETE [FROM] tabel \nFROM tabele_cuplate\n[WHERE condiţie];\nSimilar comenzii UPDATE, comanda DELETE şterge anumite înregistrări în funcţie de condiţia din clauza WHERE. În lipsa clauzei WHERE vor fi şterse toate înregistrările din tabelul dat. În această clauză pot fi incluse şi subinterogări.\nDe exemplu următoarea comandă şterge toate înregistrările pentru care gradul didactic este asistent\nDELETE tDetaliiBon\nŞterge toate rândurile tabelului tDetaliiBon\nDELETE tDetaliiBon where NrBon=’101’\nŞterge toate rândurile tabelului tDetaliiBon pentru care NrBon=’101’\nDELETE tDetaliiBon \nfrom tBonuriConsum A inner join tDetaliiBon B on A.NrBon=B.NrBon \nwhere dataBon \u0026lt;\u0026lsquo;01/01/2008\u0026rsquo;\nDELETE tBonuriConsum where dataBon \u0026lt;\u0026lsquo;01/01/2008\u0026rsquo;\nDacă tabelul din care ştergem este implicat în diverse legături cu alte tabele ca partea unu a unei legături unu la multi şi opţiunea delete cascading este activată atunci ştergerea unui rând va genera ştergerea tuturor rândurilor ce corespund la cheie din tabelele secundare corelate.\naltertabletDetaliiBon\naddconstraintFk_NrBon_tDet \nforeignkey(NrBon)\nreferencestBonuriConsum (NrBon)ondeletecascade\ndeletefromtBonuriConsum whereNrBon=\u0026lsquo;104\u0026rsquo;\nva produce stergerea automată din tabelul tDetaliiBon a tuturor rândurilor pentru care NrBon=’104’\nComanda TRUNCATE  \nPentru a şterge în mod rapid toate înregistrările dintr-o tabelă se foloseşte comanda TRUNCATEcu următoarea sintaxă:\nTRUNCATE TABLE tabel \nExemplu\ntruncatetabletModiPret\nŞtergerea înregistrărilor cu ajutorul comenzii TRUNCATEeste mult mai avantajoasă decât eliminarea tabelului şi recrearea lui ulterioară deoarece eliminarea tabelului necesită recrearea indecşilor, constrângerilor de integritate, declanşatoarelor etc.   \n"
},
{
	"uri": "https://danielanicolae.com/programare/parcurgerea_grafurilor/",
	"title": "Parcurgerea Grafurilor",
	"tags": [],
	"description": "",
	"content": "   PARCURGEREA GRAFURILOR NEORIENTATE Definiţie Prin parcurgerea (traversarea) grafului se înţelege examinarea în mod sistematic a nodurilor sale, astfel încât fiecare nod să fie atins o singură dată. Procedeul se mai numeşte vizitare.\nObs.Graful este o structură neliniară de organizare a datelor, rolul traversării este tocmai acela de a determina o “liniarizare” a nodurilor în vederea trecerii de la unul la altul.\nparcurgerea în lăţime:se parcurge mai întâi nodul iniţial, apoi vecinii acestuia, apoi vecinii nevizitaţi ai acestuia, s.a.m.d. Pentru reţinerea nodurilor se foloseşte o structură de date de tip coadă.parcurgerea în adâncime:se parcurge mai intâi nodul iniţial, continuă cu primul dintre vecinii săi nevizitaţi, apoi primul dintre vecinii nevizitaţi ai acestui nod, s.a.m.d. Pentru reţinerea noduriloR se foloseşte o structură de date de tip stivă sau se recomanda utilizarea functiilor recursiveParcurgerea grafurilor.docx   \n"
},
{
	"uri": "https://danielanicolae.com/programare/pointeri_referinte/",
	"title": "Pointeri si Referinte",
	"tags": [],
	"description": "",
	"content": "  Referinte si Pointeri.pdf   \n"
},
{
	"uri": "https://danielanicolae.com/programare/programare_foxpro/",
	"title": "Programare FoxPRO",
	"tags": [],
	"description": "",
	"content": "  Mecanismele programarii în Visual FoxPro\nProgramarea în Visual FoxPro implica scrierea unor secvente de cod: instructiuni sub forma de comenzi, functii sau operatii pe care Visual FoxPro le poate interpreta. Acestea pot fi introduse în:\n- fisiere de programe;\n- ferestre de cod pentru evenimente sau metode în cadrul proiectantului de formulare (Form Designer) sau al proiectantului de clase (Class Designer);\n- ferestre procedurale în cadrul proiectantului de meniuri (Menu Designer);\n- ferestre procedurale în cadrul proiectantului de rapoarte (Report Designer).\nCrearea de programe - 1. în Project Manager se selecteaza optiunea Programs din fila Code;\n2. se alege comanda New\n- 1. se alege comanda New din meniul File\n2. din caseta de dialog New se alege Program\n3. se alege New File.- în fereastra Command se foloseste comanda MODIFY COMMAND \nMODIFY COMMAND [FileName | ?] \nVisual Fox Pro va deschide o noua fereastra, în care se pot edita instructiunile programului.\nSalvarea programelor - din meniul File se alege Save\n- daca se salveaza un program creat în Progect Manager , acesta este automat adaugat proiectului.\nModificarea programelor Înainte de a modifica un program, acesta trebuie redeschis prin una din urmatoarele metode:\n- pentru programele cuprinse într-un proiect, se selecteaza în Project Manager si se alege comanda Modify\n- în meniul File se alege comanda Open. Din lista Files of Type se alege Program, se selecteaza fisierul de modificat si se alege comanda Open.\n- Se foloseste comanda MODIFY COMMAND în care se specifica numele programului sau parametrul \u0026quot;?\u0026quot;.\nRularea programelor - daca programul este cuprins într-un proiect, se selecteaza din Project Manager si se alege comanda Run.\n- Din meniul Program se alege comanda Do\n- Se foloseşte butonul de execuţie din bara de instrumente \n- în fereastra de comenzi se foloseste comanda DO\nDO ProgramName1 | ProcedureName [IN ProgramName2] [WITH ParameterList]\nConceptele de baza ale programării\nVariabile. Macrosubstituţia.\nCrearea unei variabile sau modificarea valorii acesteia se face prin una din metodele următoare:\n(1) memvar = expr\nExemplu: msal=1000\nmdata=date()\n(2)STORE expr TO lista var\nO tehnica speciala de lucru cu variabile o reprezintamacrosubstitutia, prin care continutul unei variabile de tip sir de caractere este tratat ca numele altei variabile sau alt element FoxPro (câmp al unei baze de date, denumire fişier). Macrosubstituţia functionează ca şi cum în locul variabilei respective ar fi pus şirul de caractere conţinut de aceasta, fără apostrofurile delimitatoare.\nOperatorul de macrosubstitutie este \u0026amp;. ( \u0026amp;\u0026amp; indică un comentariu)\nExemplu:1. a=”var” \nvar= ”Continutul variabilei var” \n? a \u0026amp;\u0026amp; se afisaza var \n? \u0026amp;a \u0026amp;\u0026amp; rezultatul afisarii este Continutul variabilei var ? var \u0026amp;\u0026amp; rezultatul afisarii este Continutul variabilei var \nObs.:Dezavantajul este ca apare o problema de performanta pentru compilator, in sensul ca linia pe care apare, trebuie compilata \u0026quot;din mers\u0026quot; in momentul rularii.\nComenzi pentru afişarea variabilelor de memorie existente la un moment dat:\nLIST / DISPLAY MEMORY [NOCONSOLE][TO PRINTER [PROMPT]| TO FILE \u0026lt;file\u0026gt;]\nManipularea datelor\na) Operatori\nOperatoriiutilizati pentru a crea expresii în Visual FoxPro sunt operatori aritmetici, operatori relationali, operatori logici, operatori specifici şirurilor de caractere: concatenare (+,-) apartenenta $, etc, operatori specifici datelor calendaristice: adunare sau scadere numar de zile dintr-o data calendaristica, compararea a doua date.\nExemplu:\n1.Fie urmatoarele valori de tip caracter stocate în variabilele v1 si v2:\nv1= \u0026quot;Univ. \u0026quot; şi v2=\u0026quot;Stefan Cel Mare\u0026quot;\nExpresia:? v1+v2 va avea ca efect afişarea pe ecran a valorii \u0026quot; Univ. Stefan Cel Mare\u0026quot;\n2. Daca variabilele v1 si v2 au valorile următoare: \nv1= \u0026quot; Str. Univ. \u0026quot; şi v2=21\nExpresia:? v1+v2 va avea ca efect afisarea pe ecran a unui mesaj de eroare.\n\nb) Comenzi\nFiecare comandă determină executarea unei acţiuni. Sintaxa generala a unei comenzi este:\nVerb\u0026lt;clauza,\u0026gt;\u0026lt; clauza \u0026gt;..\nUnde: verb indica acţiunea ce trebuie executată iar clauzele sunt opţionale si furnizează informaţii suplimentare legate de modul cum se va executa actiunea\nDaca o comanda este scrisa pe mai mult de o linie, atunci la sfarsitul fiecarei linii intermedare se va plasa simbolul “;”.\n1. Instructiuni (comenzi) de intrare-iesire \nSunt instructiuni de afisare si instructiuni pentru citirea de la tastatura.\na) Instructiuni de afisare.\nAceasta categorie de comenzi cuprinde urmatoarele instructiuni:\n(1)? Expr1 [PICTURE Cod_format] | [FUNCTION Cod_format] |[AT nColumn] [FONT Nume_font [,Dimens_Font] \nEfect:Afiseaza, pe ecran, valorile uneia sau mai multor expresii Visual FoxPro valide sau le tipareste la imprimanta, daca SET PRINTER este pe ON , conform valorilor clauzelor PICTURE, FUNCTION,etc.\nObs.: - clauza AT \u0026lt;expN1\u0026gt; defineste coloana unde se afiseaza \u0026lt;expr1\u0026gt;;\nb) Instructiuni de citire de la tastatura.\n(1) ACCEPT [\u0026lt;cExpr\u0026gt; ] TO \u0026lt;memvar\u0026gt;\nSe afiseaza pe ecran valoarea \u0026lt;cExpr\u0026gt; dupa care se asteapta introducerea unui sir de caractere, de la tastatura, ce se atribuie variabilei de memorie \u0026lt;memvar\u0026gt;.\n\n(2) INPUT [\u0026lt;cExpr\u0026gt; ] TO \u0026lt;memvar\u0026gt;\nSe afiseaza pe ecran valoarea \u0026lt;cExpr\u0026gt; dupa care se asteapta introducerea unei expresii de la tastatura, a carei valoare se atribuie variabilei de memorie \u0026lt;memvar\u0026gt;.\nObs.:- comanda cere obligatoriu introducerea unei expresii; - pentru introducerea constantelor de tip sir sau data calendaristica se vor folosi delimitatorii specifici (\u0026quot;,\u0026lsquo;,[ ], resp. {}).\n\n-transformarea şirurilor de caractere in valori numerice\nVAL(cExpr)\nANEXA 2Instrucţiuni (comenzi) de configurare\nInstructiuni pentru controlul formatului datei calendaristice\nSET CENTURY ON/OFF / validează, respectiv invalidează afişarea anului pe patru digiţi\nSET DATE TO DMY|MDY| BRITISH|FRENCH| GERMAN – stabileşte formatul de afişare a datei calendaristice\nInstructiuni pentru controlul formatului de afişare al ceasului sistem:\nSET CLOCK ON | OFF – validează/invalidează afişarea ceasului \nSET CLOCK TO [\u0026lt;ROW\u0026gt;,\u0026lt;COL\u0026gt;]- stabileşte poziţia pe ecran în care se va afişa ceasul\nSET HOURS TO [12 | 24] – stabileşte formatul de afişare al orei\nDiverse instrucţiuni de configurare\nSET BELL ON/OFF – validează/invalidează alarma sonoră a mediului\nSET CARRY ON/OFF – validează/invalidează păstrarea valorilor din înregistrarea curentă pentru o nouă înregistrare introdusă prin una din comenzile INSERT, APPEND sau BROWSE\nSET DATABASE TO [NumeBD] – stabileşte baza de date curentă\nSET DEFAULT TO [Specificator_director] – stabileşte directorul curent\nSET DELETED ON/OFF – invalidează/validează utilizarea înregistrărilor marcate pentru ştergere în comenzi ulterioare\nSET ESCAPE ON/OFF – validează/invalidează întreruperea execuţiei unui program sau a unei comenzi la apăsarea tastei ESCAPE\nSET EXCLUSIVE ON/OFF – stabileşte dacă fişierele tabel vor fi deschise pentru uzul exclusiv sau partajat într-o reţea\nSET LOCK ON/OFF – validează/invalidează blocarea automată a tabelelor pentru anumite comenzi.\nSET PATH TO [lista_cai_de_cautare] – stabileşte o listă a căilor de căutare pentru fişiere\nSET TALK ON/OFF – validează/invalidează afişarea rezultatelor comenzilor Visual FoxPro   \n"
},
{
	"uri": "https://danielanicolae.com/programare/programare_orientata_pe_obiecte/",
	"title": "Programare Orientata pe Obiecte",
	"tags": [],
	"description": "",
	"content": "  Aplicații practice de laborator POO.pdf Curs programare orientată pe obiecte curs poo   \n"
},
{
	"uri": "https://danielanicolae.com/programare/programare_dinamica/",
	"title": "Programarea Dinamica",
	"tags": [],
	"description": "",
	"content": "  Programare Dinamica\nProgramare dinamica presupune rezolvarea unei probleme prin descompunerea ei in subprobleme si rezolvarea acestora. Spre deosebire de divide-et-impera, subproblemele nu sunt disjuncte, ci se suprapun.\nPentru a evita recalcularea portiunilor care se suprapun, rezolvarea se face pornind de la cele mai mici subprobleme si folosindu-ne de rezultatul acestora calculam subproblema imediat mai mare. Cele mai mici subprobleme sunt numite subprobleme unitare. Acestea pot fi rezolvate intr-o complexitate constanta, ex: cea mai mare subsecventa dintr-o multime de un singur element.\nPentru a nu recalcula solutiile subproblemelor ce ar trebui rezolvate de mai multe ori, pe ramuri diferite, se retine solutia subproblemelor folosind o tabela (matrice uni, bi sau multidimensionala in functie de problema) cu rezultatul fiecarei subprobleme. Aceasta tehnica se numeste memorizare.\nAceasta tehnica afla „valoarea” solutiei optime pentru fiecare din subprobleme. Mergand de la subprobleme mici la subprobleme din ce in ce mai mari ajungem sa gasim „valoarea” problemei intregi. Motivul pentru care aceasta tehnica se numeste Programare Dinamica este datorat flexibilitatii ei, „valoarea” schimbandu-si intelesul logic de la o Problema la alta. In probleme de minimizarea costului, „valoarea” este acest cost minim. In probleme de aflarea unei componente maxime, „valoarea” este dimensiunea componentei.\nDupa calcularea valorii pentru toate subproblemele se pot afla efectiv elementele ce alcatuiesc solutia.\n„Reconstructia” solutiei se face mergand din subproblema in subproblema incepand de la problema cu valoarea optima si ajungand in subprobleme unitare. Metoda admite nuante in cazuri particulare, o sa se inteleaga mai bine din exemple.\nAplicand aceasta tehnica determinam una din solutiile optime, problema putand avea mai multe solutii optime. In cazul in care se doreste determinarea tuturor solutiilor optime, algoritmul trebuie combinat cu unul de backtracking in reconstructia solutiilor.\nDupa cum probabil ati intuit deja, diferenta majora dintre cele doua metode prezentate este ca algoritmul greedy mentine doar solutiile partiale de la pasul curent pentru a le folosi la pasul urmator, in timp ce programarea dinamica poate utiliza la un pas subsolutii generate la oricare alt pas anterior.\nProgramarea Dinamica poate fi descompusa in urmatoarea secventa de pasi:\n1. Descoperirea structurii si \u0026quot;masurii\u0026quot; pe care o are o solutie optima.\n2. Determinarea unei metode de calcul recursive pentru a afla valoarea fiecarei subprobleme.\n3. Calcularea \u0026quot;de jos in sus\u0026quot; a acestei valori (de la subproblemele cele mai mici la cele mai mari)\n4. Reconstructia solutiei optime pornind de la rezultatele obtinute anterior.\nExemple de probleme:\n1.Determinarea celui mai lung subsir strict crescator dintr-un sir de numere. Un subsir al unui sir este format din caractere (nu neaparat consecutive) ale sirului respectiv, in ordinea in care acestea apar in sir.\nExemplu: şirul {2, 4, 3, 5, 3, 6} are cel mai lung subsir crescator de lungime 4: {2, 4, 5, 6} sau {2, 3, 5, 6}.\nRezolvare:\nSoluţia problemei nu este unică, dar lungimea maximă a subşirului crescător, da.\nVom nota cu L[k] lungimea celui mai lung subşir crescător care începe de la poziţia k şi până la sfârşitul şirului iniţial. Calculăm, pe rând, L[n], L[n-1], L[n-2] … L[2], L[1]. Lungimea celui mai lung subşir crescător va fi dată de cea mai mare valoare a lui L.\nL[n] = 1\nL[k] = 1+ max {L[i ], unde k\u0026lt;i≤n şi v[k]≤v[i ]}, k=n-1,1\n#include\u0026lt;fstream.h\u0026gt;\nint v[10000],n,i,L[1000],max,mx,k,t;\nvoid main(){\nfstream f(\u0026quot;subsir.txt\u0026quot;,ios::in);\nfor(i=1;i\u0026lt;=n;i++) f\u0026gt;\u0026gt;v[i];\nL[n]=1; subsir maxim de lung 1\nfor(k=n-1;k\u0026gt;0;k\u0026ndash;)\n{mx=0;\nfor(i=k+1;i\u0026lt;=n;i++)\nif(v[i]\u0026gt;=v[k] \u0026amp;\u0026amp; L[i]\u0026gt;mx)\nmx=L[i];\nL[k]=mx+1;\nif(L[k]\u0026gt;max)\n{max=L[k];\nt=k;}\n}\ncout\u0026lt;\u0026lt;\u0026quot;lungimea maxima:\u0026quot;\u0026lt;\u0026lt;max;\nafisarea subsirului\ncout\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;v[t]\u0026lt;\u0026lt;\u0026rsquo; \u0026lsquo;;\nfor(i=t+1;i\u0026lt;=n;i++)\nif ((v[i]\u0026gt;=v[t]) \u0026amp;\u0026amp; (L[i]==max-1))\n{cout\u0026lt;\u0026lt;v[i]\u0026lt;\u0026lt;\u0026rsquo; \u0026lsquo;;\nmax\u0026ndash;;}\n}\n2. Subşir comun maximal\nFie X=(x1, x2, \u0026hellip;, xn) şi Y=(y1, y2, \u0026hellip;, ym) două şiruri de n, respectiv m numere întregi. Determinaţi un subşir comun de lungime maximă.\nExemplu\nPentru X=(2,5,5,6,2,8,4,0,1,3,5,8) şi Y=(6,2,5,6,5,5,4,3,5,8) o soluţie posibilă este: Z=(2,5,5,4,3,5,8)\nRezolvare:\nNotăm cu Xk=(x1, x2, \u0026hellip;, xk) (prefixul lui X de lungime k) şi cu Yh=(y1, y2, \u0026hellip;, yh) prefixul lui Y de lungime h. O subproblemă a problemei date constă în determinarea celui mai lung subşir comun al lui Xk, Yh. Notăm cu LCS(k,h) lungimea celui mai lung subşir comun al lui Xk, Yh. Utilizând aceste notaţii, problema cere determinarea LCS(n,m), precum şi un astfel de subşir.\nPentru a reţine soluţiile subproblemelor vom utiliza o matrice cu n+1 linii şi m+1 coloane, denumită LCS. Linia şi coloana 0 sunt iniţializate cu 0, iar elementul LCS[k][h] va fi lungimea celui mai lung subşir comun al şirurilor Xk şi Yh.\nVom caracteriza substructura optimală a problemei prin următoarea relaţie de recurenţă:\nlcs[k][0]=lcs[0][h]=0, k din {1,2,..,n}, h din {1,2,..,m}\nlcs[k][h]=1+lcs[k-1][h-1], dacă x[k]=y[h]\nmax{lcs[k][h-1], lcs[k-1][h]}, dacă x[k]\u0026lt;\u0026gt;y[h]\n#include\u0026lt;fstream.h\u0026gt;\nint x[100],y[100],n,m;\nint lcs[100][100],max;\nvoid rezolva(){\nfor(int k=1;k\u0026lt;=n;k++)\nfor(int h=1;h\u0026lt;=m;h++)\nif(x[k]==y[h]) lcs[k][h]=1+lcs[k-1][h-1];\nelse\nif (lcs[k-1][h]\u0026gt;lcs[k][h-1]) lcs[k][h]=lcs[k-1][h];\nelse lcs[k][h]=lcs[k][h-1];\n}\nvoid afiseaza_solutie_max(int k,int h){\nif(lcs[k][h])\nif(x[k]==y[h])\n{afiseaza_solutie_max(k-1,h-1);\ncout\u0026lt;\u0026lt;x[k]\u0026lt;\u0026lt;\u0026rsquo; \u0026lsquo;;}\nelse\n{if (lcs[k][h]==lcs[k-1][h])\nafiseaza_solutie_max(k-1,h);\nelse if (lcs[k][h]==lcs[k][h-1])\nafiseaza_solutie_max(k,h-1);\n}\n}\nvoid main(){\nifstream f(\u0026quot;lcs.txt\u0026quot;,ios::in);\nf\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m;\nfor(int i=1;i\u0026lt;=n;i++) f\u0026gt;\u0026gt;x[i];\nfor(i=1;i\u0026lt;=m;i++) f\u0026gt;\u0026gt;y[i];\nrezolva();\nafiseaza_solutie_max(n,m);\n}\n3. Sumă maximă în triunghi\nFie triunghiul format din n linii (1\u0026lt;n\u0026lt;=100), fiecare linie conţinând numere întregi din domeniul [1,99], ca în exemplul următor:\nImage\nDeterminaţi cea mai mare sumă de numere aflate pe un drum între numărul de pe prima linie şi un număr de pe ultima linie. Fiecare număr din acest drum este situat sub precedentul, la stânga sau la dreapta acestuia.\nRezolvare\n1. Vom reţine triunghiul într-o matrice pătratică T, de ordin n, sub diagonala principală. Subproblemele problemei date constau în determinarea sumei maxime care se poate obţine din numere aflate pe un drum între numărul T[i ][j], până la un număr de pe ultima linie, fiecare număr din acest drum fiind situat sub precedentul, la stânga sau la dreapta sa. Evident, subproblemele nu sunt independente: pentru a calcula suma maximă a numerelor de pe un drum de la T[i ][j] la ultima linie, trebuie să calculăm suma maximă a numerelor de pe un drum de la T[i+1][j] la ultima linie şi suma maximă a numerelor de pe un drum de la T[i+1][j+1] la ultima linie.\n2. Pentru a reţine soluţiile subproblemelor, vom utiliza o matrice suplimentară S, pătratică de ordin n, cu semnificaţia\nS[i ][j]= suma maximă ce se poate obţine pe un drum de la T[i ][j] la un element de pe ultima linie, respectând condiţiile problemei.\nSoluţia problemei va fi S[1][1].\n3. Relaţia de recurenţă care caracterizează substructura optimală a problemei este:\nS[n][ i]=T[n][i ], i din {1,2,\u0026hellip;,n}\nS[i ][j]=T[i ][j]+max{S[i+1][j], S[i+1][j+1]}\nSecvenţa de program este:\nfor (i=1; i\u0026lt;=n; i++) S[n][i]=T[n][i];\nfor (i=n-1; i\u0026gt;=1; i\u0026ndash;)\nfor (j=1; j\u0026lt;=i; j++)\n{if (S[i+1][j]\u0026lt;S[i+1][j+1])\nS[i][j]=T[i][j]+S[i+1][j+1]);\nelse\nS[i][j]=T[i][j]+S[i+1][j];}\nSUMATRI.cpp\nPROBLEME PROPUSE\n1. Împărţirea unei mulţimi în 2 submulţimi de sume cât mai apropiate\nLa sfarsitul noptii de Craciun, Mosul a poposit la bradul a doi frati, unde si-a golit sacul. Cand s-au trezit, fratii au intrat intr-o mare dilema: cum isi vor imparti ei cadourile mosului? Stiind ca fiecare cadou are o valoare (cuprinsa intre 1 si 100 inclusiv) si ca sunt maxim 100 de cadouri scrieti un program care sa determine sumele cadourilor fratilor, precum si modul de impartire, astfel incat sumele obtinute sa fie cele mai apropiate posibil.\nDate de intrare:\nIn fisierul CADOURI.IN se gasesc informaţiile referitoare la cadouri: pe prima linie numarul total de cadouri, pe urmatoarea linie valorile lor.\nDate de iesire: In fişierul CADOURI.OUT trebuie scrise doua sume care sunt cele mai apropiate corespunzătoare unei impartiri a cadourilor, pe a doua linie valorile corespunzătoare cadourilor care însumează prima suma găsită, pe a treia linie, valorile corespunzătoare cadourilor care însumează a doua suma găsită.\nExemplu:\nCADOURI.IN CADOURI.OUT\n7 48 49\n28 7 11 8 9 7 27 28 11 9\n7 8 7 27\n2. Sumă maximă\nSe consideră un şir de N (N£1000) numere naturale cuprinse între 1 şi 10.000. Să se determine o sumă maximă de componente ale şirului astfel încât în sumă să nu intre două numere care se află pe poziţii consecutive în şir.\nExemplu: pentru şirul 1 10 2 40 100, suma maximă este 110 (10+100)   \n"
},
{
	"uri": "https://danielanicolae.com/programare/recursivitate/",
	"title": "Recursivitate",
	"tags": [],
	"description": "",
	"content": "  Recursivitatea este un mecanism general de elaborare a algoritmilor. O functie se numeste recursiva daca ea se autoapeleaza, fie direct (in definitia ei, se face apel la ea insasi), fie indirect (functia X apeleaza functia Y, care apeleaza functia X).\nRecursivitatea a aparut din necesitati practice date de transcrierea directa a formulelor matematice recursive. Apoi, acest mecanism a fost extins, fiind utilizat in elaborarea multor algoritmi.\nPornim de la un exemplu : Sa se calculeze n !\nSe observa ca n !=(n-1) !*n si se stie ca 0 !=1. Asadar :\n5 !=4 !*5\n4 !=3 !*4\n3 !=2 !*1\n1 !=0 !*1\n0 !=1 (prin conventie matematica)\nFunctia recursiva se va scrie astfel:\nlong factorial(int n)\n{if(n==0) return 1;\nelse return factorial(n-1)*n;}\nvoid main()\n{cout\u0026lt;\u0026lt;factorial(5) ;}\nSe observa ca functia factorial se autoapeleaza. Autoapelul se realizeaza prininstructiuneareturn factorial(n-1)*n.\nSa vedem care este mecanismul prin care subprogramele se pot autoapela. Se stie ca la apelul fiecarui subprogram, se genereaza un nou nivel in segmentul de stiva, corespunzator acelui apel. Pe acel nivel se memoreaza :\n- valorile parametrilor transmisi prin valoare\n- adresele parametrilor transmisi prin referinta\n- variabilele locale\nFiecare apel de functie lucreaza cu datele aflate pe nivelul corespunzator acelui apel. La iesirea din apelul unei functii, nivelul respectiv se elibereaza si datele aflate acolo se pierd. Exista posibilitatea ca subprogramul sa lucreze direct cu variabilele globale, dar in acest caz, subprogramul isi pierde independenta.\nCum gandim un algoritm recursiv ?\nIata cateva exemple de rationament recursiv :\n- O camera de luat vederi are in obiectiv un televizor care transmite imaginile primite de la camera. In televizor se vede un televizor in care se vede un televizor…\n- Anunt : Azi nu se fumeaza !\nO gandire recursiva exprima concentrat o anumita stare, care se repeta la infinit. Aceasta gandire se aplica in elaborarea algoritmilor recursivi cu o modificare esentiala: adaugarea conditiei de terminare. In absenta acestei conditii nu se poate vorbi despre un algoritm deoarece acestia sunt finiti. Din acest punct de vedere, exemplele de mai sus nu sunt corecte.Atunci cand gandim un algoritm recursiv, privim problema la un anumit nivel. Ce se intampla la acel nivel se va intampla la toate celelalte.\nObservatii :\n- In cazul unui numar mare de autoapelari, exista posibilitatea ca segmentul de stiva sa se ocupe total, caz in care programul se va termina cu eroarea STACK OVERFLOW. Aceasta se intampla mai ales atunci cand conditia de terminare este pusa gresit si subprogramul se apeleaza la nesfarsit.\n- Pentru orice algoritm recursiv exista unul iterativ care rezolva aceeasi problema.\n- Mecanismul recursivitatii inlocuieste instructiunile repetitive.\n- Datorita faptului ca la fiecare autoapel se ocupa o zona de memorie, recursivitatea este eficienta numai daca numarul de autoapelari nu este prea mare pentru a nu se ajunge la umplerea zonei de memorie alocata.\n- Recursivitatea ofera avantajul unor solutii mai clare pentru probleme si a unei lungimi mai mici a programului. Ea prezinta insa dezavantajul unui timp mai mare de executie si a unui spatiu de memorie alocata mai mare. Este de preferat ca atunci cand programul recursiv poate fi transformat cu usurinta intr-unul iterativ sa se faca apel la cel din urma (vezi sirul lui Fibonacci)\nExemplu de functii ce calculeaza produsul primelor n numere naturale :\nFunctia iterativa int f(int n)\n{int i=1, P=1;\nwhile (i\u0026lt;=n)\n{P=P*i ;\ni++ ;}\nreturn P ;}\nvoid main()\n{int n=5;\ncout\u0026lt;\u0026lt;f(n);}\nFunctia recursiva 1 int n;\nint f(int i)\n{if (i\u0026lt;=n)\nreturn i*f(i+1);\nelse return 1 ;}\nvoid main()\n{n=5;\ncout\u0026lt;\u0026lt;f(1);}\nFunctia recursiva 2 int f(int i)\n{if (i\u0026gt;1)\nreturn i*f(i-1);\nelse return 1 ;}\nvoid main()\n{int n=5;\ncout\u0026lt;\u0026lt;f(n);}\nObservati ca la primele doua subprograme conditia de continuare (a iteratiei respectiv a autoapelului este aceeasi)\nRecomandare : inainte de elaborarea algoritmilor recusivi generati mai intai subprogramul iterativ apoi treceti-l in subprogram recursiv.\nTESTE GRILA Grile recursivitate3.pdf\ngrile recursivitate1.doc\nGrile recursivitate 2.doc\nAplicatii rezolvate online http://info.mcip.ro/?cap=Recursivitate   \n"
},
{
	"uri": "https://danielanicolae.com/programare/roy_warshall_kruskal_dijkstra/",
	"title": "Roy Warshall, Kruskal, Dijkstra etc.",
	"tags": [],
	"description": "",
	"content": "   Curs-Algoritmica-Grafurilor.pdf\nDIJKSTRA DIJKSTRA.docx   \n"
},
{
	"uri": "https://danielanicolae.com/programare/sql/",
	"title": "SQL",
	"tags": [],
	"description": "",
	"content": "  \nCurs Bd.pdf APLICATII TEST 1.docx MEMENTO Limbajul SQL.pdf\nTEST 2.docx teste grila sql.pdf   \n"
},
{
	"uri": "https://danielanicolae.com/programare/siruri_de_caractere/",
	"title": "Siruri de Caractere",
	"tags": [],
	"description": "",
	"content": "  Notiuni teoretice SIRURI DE CARACTERE.doc\nTESTE GRILA TESTE GRILA.docx\nPROBLEME PROPUSE http://info.mcip.ro/?cap=Siruri%20de%20caractere\n\nProbleme backtracking.doc\nPROBLEME REZOLVATE 1. Se citeşte de la tastatură un cuvânt. Să se afişeze numărul iniţial de caractere ale cuvântului şi apoi să se şteargă toate vocalele din cuvânt.\n#include\u0026lt;iostream.h\u0026gt;\n#include\u0026lt;string.h\u0026gt;\n#include\u0026lt;conio.h\u0026gt;\nvoid main()\n{int i;\nchar s[100];\ncout\u0026lt;\u0026lt;\u0026quot;s=\u0026quot;;cin.get(s,100);\ncout\u0026lt;\u0026lt;\u0026quot;Sirul are: \u0026quot;\u0026lt;\u0026lt;strlen(s)\u0026lt;\u0026lt;\u0026quot; caractere\u0026quot;\u0026lt;\u0026lt;endl;\nstrlwr(s);\nfor(i=0;i\u0026lt;strlen(s);i++)\nif(s[i]==\u0026lsquo;a\u0026rsquo;||s[i]==\u0026lsquo;e\u0026rsquo;||s[i]==\u0026lsquo;i\u0026rsquo;||s[i]==\u0026lsquo;o\u0026rsquo;||s[i]==\u0026lsquo;u\u0026rsquo;)\nstrcpy(s+i,s+i+1);\ncout\u0026lt;\u0026lt;\u0026quot;sirul fara vocale=\u0026quot;\u0026lt;\u0026lt;s;\n}\n2. Se citesc de la tastatură 2 şiruri de caractere. Să se verifice dacă sunt egale (la fel) fără a se face deosebire între literele mari şi literele mici.\n#include\u0026lt;iostream.h\u0026gt;\n#include\u0026lt;string.h\u0026gt;\n#include\u0026lt;conio.h\u0026gt;\nchar s1[100],s2[100];\nvoid citire()\n{\ncout\u0026lt;\u0026lt;\u0026quot;primul sir: \u0026quot;;cin.get(s1,100);cin.get();\ncout\u0026lt;\u0026lt;\u0026quot;al doilea sir \u0026quot;;cin.get(s2,100);\n}\nvoid compara()\n{int x;\nx=stricmp(s1,s2);\nstrlwr(s1);strlwr(s2);\n//transformam cele doua siruri in siruri numai cu litere mici\nif(x\u0026gt;0) cout\u0026lt;\u0026lt;\u0026quot;Primul sir este mai mare\\n \u0026quot;;\nelse if(x==0) cout\u0026lt;\u0026lt;\u0026quot;Siruri sunt egale\\n \u0026quot;;\nelse cout\u0026lt;\u0026lt;\u0026quot;Al doilea sir este mai mare decat primul\\n \u0026quot;;\n}\nvoid main()\n{citire();\ncompara();\n}\n3. Fişierul litere.txt conţine un text scris cu litere mari pe una sau mai multe linii. Se cere:\na) Să se afişeze litera ( literele) care apare de cele mai multe ori;\nb) Să se afişeze vocalele din text.\n#include\u0026lt;iostream.h\u0026gt;\n#include\u0026lt;string.h\u0026gt;\n#include\u0026lt;fstream.h\u0026gt;\n#include\u0026lt;io.h\u0026gt;\nifstream f(\u0026quot;litere.txt\u0026quot;);\nint n;\nchar a[100];\nvoid citire()\n{int i;\ni=0;\nf\u0026gt;\u0026gt;a[i];\nwhile(!f.eof())\n{cout\u0026lt;\u0026lt;a[i];\ni++;\n/pt nu a avea surprize ca fisierul sa nu aiba decat majuscule\ntransformam sirul in majusculele/\nstrupr(a);\nf\u0026gt;\u0026gt;a[i];\n}\nn=i;\nf.close();\n}\nvoid maxim()\n{\nint b[50];\ncout\u0026lt;\u0026lt;\u0026quot;\\n numarul de caractere=\u0026quot;\u0026lt;\u0026lt;n\u0026lt;\u0026lt;\u0026quot;\\n\u0026quot;;\nint k=0;\nfor(char c=\u0026lsquo;A\u0026rsquo;;c\u0026lt;=\u0026lsquo;Z\u0026rsquo;;c++){\nb[k]=0;\nfor(int j=0;j\u0026lt;n;j++)\nif(c==a[j]) b[k]++;\nk++;\n}\nint max=b[0];\nfor(int i=1;i\u0026lt;k;i++)\nif(max\u0026lt;b[i])max=b[i];\ncout\u0026lt;\u0026lt;\u0026quot;caracterele cu numar maxim de aparitii=\u0026quot;\u0026lt;\u0026lt;max\u0026lt;\u0026lt;endl;\nfor(i=0;i\u0026lt;k;i++)\nif(b[i]==max)cout\u0026lt;\u0026lt;char(65+i)\u0026lt;\u0026lt;\u0026quot; \u0026quot;;\n}\nvoid vocale()\n{char voc[]=\u0026quot;AEIOU\u0026quot;;\ncout\u0026lt;\u0026lt;\u0026quot;\\nvocalele din text\\n\u0026quot;;\nfor(int i=0;i\u0026lt;n;i++)\nfor(int j=0;j\u0026lt;strlen(voc);j++)\nif(a[i]==voc[j])cout\u0026lt;\u0026lt;a[i]\u0026lt;\u0026lt;\u0026quot; \u0026quot;;\ncout\u0026lt;\u0026lt;\u0026quot;\\n\u0026quot;;\n}\nvoid main()\n{citire();\nmaxim();\nvocale();\n}\n4. Se citeşte un text într-o variabilă de tip string, in care cuvintele se despart prin spaţii. Se cere:\na) să se afişeze cuvintele în ordine alfabetică;\nb) să se numere cuvintele cu minim 4 vocale distincte.\n#include \u0026lt;iostream.h\u0026gt;\n#include \u0026lt;conio.h\u0026gt;\n#include \u0026lt;string.h\u0026gt;\nchar cuv[10][10];\nint n;\nvoid sortare()\n{ char aux[10];int x;\nfor(int i=1;i\u0026lt;n;i++)\nfor(int j=1+i;j\u0026lt;=n;j++)\n{x=strcmp(cuv[i],cuv[j]);\nif(x\u0026gt;0){\nstrcpy(aux,cuv[i]);\nstrcpy(cuv[i],cuv[j]);\nstrcpy(cuv[j],aux);\n}\n}\nfor(i=1;i\u0026lt;=n;i++)cout\u0026lt;\u0026lt;cuv[i]\u0026lt;\u0026lt;\u0026quot; \u0026quot;;\ncout\u0026lt;\u0026lt;endl;\n}\nint nrvocale(char s[10])\n{char vocale[]=\u0026quot;aeiou\u0026quot;;int c;int nr=0;\nstrlwr(s);\nfor(int i=0;i\u0026lt;strlen(vocale);i++)\n{ c=0;\nfor(int j=0;j\u0026lt;strlen(s);j++)\nif(vocale[i]==s[j])c++;\nif(c!=0)nr++;\n}\nif (nr\u0026gt;=4)return 1;\nelse return 0;\n}\nvoid vocale4()\n{\nfor(int i=1;i\u0026lt;=n;i++)\nif(nrvocale(cuv[i])==1)cout\u0026lt;\u0026lt;cuv[i]\u0026lt;\u0026lt;\u0026quot; \u0026quot;;\ncout\u0026lt;\u0026lt;\u0026quot;\\n\u0026quot;;\n}\nint main()\n{char a[100],*p,separator[]=\u0026quot; \u0026quot;;\nint i=0,nr=0;\ncout\u0026lt;\u0026lt;\u0026quot;Dati sirul:\u0026quot;;cin.get(a,100);\nstrcpy(p,a);\np=strtok(p,separator);\nwhile (p)\n{strcpy(cuv[++nr],p);\np=strtok(NULL,separator);}\ncout\u0026lt;\u0026lt;\u0026quot;Sunt \u0026quot;\u0026lt;\u0026lt;nr\u0026lt;\u0026lt;\u0026quot; cuvinte:\u0026quot;\u0026lt;\u0026lt;endl;\nfor (i=1;i\u0026lt;=nr;i++) cout\u0026lt;\u0026lt;cuv[i]\u0026lt;\u0026lt;endl;\nn=nr;\nsortare();\nvocale4();\nreturn 0;\n}   \n"
},
{
	"uri": "https://danielanicolae.com/programare/space.menu/",
	"title": "Space.Menu",
	"tags": [],
	"description": "",
	"content": "  ORA DE DIRIGENTIE\nEVALUARE PLATFORMA\nEVALUARE PORTOFOLII\nTIC\nCURS C\nC++ BUILDER\nEXPRESII\nALGORITMI\nSTRUCTURI\nTABLOURI\nMETODE DE SORTARE\nAPLICATII COMPLEXE\nTIPUL STRUCT\nFIŞIERE TEXT\nPOINTERI SI REFERINTE\nSIRURI DE CARACTERE\nSUBPROGRAME\nRECURSIVITATE\nDIVIDE ET IMPERA\nBACKTRACKING\nGREEDY\nLISTE LINIARE\nPROGRAMAREA DINAMICA\nPROGRAMARE ORIENTATA PE OBIECTE\nGRAFURI NEORIENTATE\nROY WARSHALL, CONEXITATE IN GRAFURI NEORIENTATE GRAFURI ORIENTATE\nPARCURGEREA GRAFURILOR\nDRUMURI MINIME/MAXIME IN GRAFURI\nKRUSKAL, DIJKSTRA, etc.\nARBORI\nARBORI DE CAUTARE, ARBORI B, COMPLEXE\u0026hellip;\nHTML\nATESTAT, COMPETENTE DIGITALE\nBAZE DE DATE\nSQL\nACCESS\nFOXPRO\nTIPURI DE DATE IN FOXPRO\nPROGRAMARE FOXPRO\nORACLE, PHP\nComunicarea într-o reţea locală**\nSCOALA POSTLICEALA\nAdministrator retele locale si de comunicatii\nSPP\nCURRICULA\nAN I\nAN II\nMateriale de predare\nMateriale de invatare\nInstrumente de evaluare\nAnalist programator\nSPP\nCURRICULA\nAN I\nAN II\nMateriale de predare\nMateriale de invatare\nInstrumente de evaluare\nhttp://cndiptfsetic.tvet.ro\nMATE BAC\nCURSURI ONLINE   \n"
},
{
	"uri": "https://danielanicolae.com/programare/structuri/",
	"title": "Structuri",
	"tags": [],
	"description": "",
	"content": "  STRUCTURA LINIARĂ1. a si b retin valorile pentru doua numere intregi citite de la tastatura. Sa se interschimbe valorile celor doua numere.\n2. Cunoscand cele 4 note obtinute de un elev la informatica pe parcursul unui semestru si nota de la teza scrieti un algoritm care sa afiseze media lui.\n3. Fie un numar format din trei cifre. Sa se afiseze cifrele sale incepand cu cifra unitatilor.\n4. Se citeste un numar natural format din 4 cifre. Afisati numerele obtinute in urmatoarele moduri:\n–schimband prima cifra cu ultima\n-schimband intre ele cifrele din mijloc\n5. Fie a un numar natural format din 5 cifre. Scrieti un algoritm care sa determine si sa afiseze numarul format din prima, a treia si a cincea cifra din a.\n6. Un melc a cazut intr-o fantana adanca de x metri. Ziua, melcul urca a cm iar noaptea aluneca b cm. In cate zile va iesi melcul din fantana?\n7. In fiecare zi lucratoare din saptamana, Pinocchio spune o minciuna in urma careia ii creste nasul cu x cm pe zi. Sambata si duminica, cand vine Gepetto acasa, pentru a nu-l supara, nu spune nici o minciuna, ba chiar ii scade nasul cu y cm/zi. In fiecare saptamana, singur acasa, Pinocchio continua sirul minciunilor. Care este lungimea nasului dupa z zile, stiind ca initial nasul are p cm? (Zilele incep cu luni)\n8. Ana a ramas singura acasa si vrea sa faca placinte. Pentru aceasta are nevoie de x grame faina, y grame zahar, z ml lapte, p oua, m kg mere. Stiind ca pretul unui kg de faina este px, al unui kg de zahar este py, litrul de lapte costa pz, kilogramul de mere costa pm si ouale sunt pp lei/buc, sa se afle pretul placintei Anei.\n9. Sa se calculeze suma 1+2+3+…+n\n10. Sa se calculeze suma k+(k+1)+…+ (k+n)\n11. Sa se determine ultima cifra a sumei x+y, unde x si y sunt date de la tastatura.\n12. Fiind dat un numar de 4 cifre, sa se construiasca inversul acestuia si sa se faca media aritmetica a cifrelor sale.\n13. Sa se determine ultimele doua cifre ale produsululi ab.\n14. O persoana are initial la banca o suma de bani S. In primele 6 luni ale anului, dobanda a fost p%, iar in urmatoarele 6 luni a fost q% din suma la care s-a adaugat si dobanda pe lunile anterioare, sa se determine suma pe care o va avea persoana la sfarsitul anului.\n15. Sa se calculeze aria si perimetrul unui:\npatrat, cunoscand lungimea laturiidreptunghi, cunoscand lungimile celor doua laturitriunghi, cunoscand cele 3 laturitrapez, cunoscand lungimile bazelor si inaltimeacerc, cunoscand razaSTRUCTURA ALTERNATIVAComparări între valorile a două variabile\n1) Date două numere, afişaţi-l pe cel mai mic. Exemplu : Date de intrare : 44 32 Date de ieşire : 32.\n2) Se introduc vârstele a doi copii. Afişaţi care copil este mai mare şi diferenţa de vârstă dintre cei doi. Exemplu : Date de intrare : 6 13 date de ieşire : al doilea copil este mai mare cu 7 ani. \n3) Se introduc punctajele a doi sportivi. Afişaţi-le în ordine descrescătoare. Exemplu: Date de intrare 100 134 Date de ieşire: 134 puncte 100 puncte\n4) Dintr-o cutie cu trei numere se extrag două numere. Cunoscând suma celor două numere extrase, să se afişeze numărul rămas în cutie. Exemplu : date de intrare : numere existente in cutie 5 12 8 suma numerelor extrase 13 date de ieşire : 12. \n5) Se dau două numere. Să se înmulţească cel mai mare cu doi şi cel mai mic cu trei şi să se afişeze rezultatele. Exemplu : date de intrare : 3 7 date de ieşire : 9 14\n6) Se introduc două numere întregi. Să se testeze dacă primul număr este predecesorul (succesorul) celui de-al doilea şi să se afişeze un mesaj corespunzător. Exemple : date de intrare : 2 4 date de ieşire : Nu ; date de intrare : 5 6 date de ieşire : Da.\nCompararea valorii unei variabile cu o constantă\n1) Se introduc două numere nenule şi un semn de operaţie (+,-,,/). Să se efectueze cu cele două numere operaţia introdusă şi să se afişeze expresia care s-a calculat urmată de semnul = şi de valoarea ei. Exemplu : Date de intrare 10 6 * Date de ieşire 10*6=60.\n2) Se introduc trei date de forma număr ordine pacient, valoare glicemie. Afişaţi numărul de ordine al pacienţilor cu glicemia mai mare decât 100. Exemplu : Date de intrare nr 6 glicemie 90 nr 10 glicemie 107 nr 21 glicemie 110 Date de ieşire 10 21\n3) Ionel spune părinţilor doar notele mai mari sau egale cu 7. Într-o zi el a luat trei note. Introduceţi-le în calculator şi afişaţi acele note pe care le va comunica şi părinţilor. Exemplu : Date de intrare 8 7 5 Date de ieşire 8 7. \n4) Se introduc două numere. Dacă al doilea număr este diferit de 0, să se afişeze câtul dintre primul şi al doilea, iar dacă este nul, să se afişeze mesajul “Împărţire imposibilă”. Exemple : Date de intrare 10 3 Date de ieşire 3.33 Date de intrare 45 0 date de ieşire Impartire imposibila.\n5) Un lift pentru copii acceptă o greutate de maxim 100 kg. Introducând în calculator greutăţile a doi copii, specificaţi prin afişarea unui mesaj corespunzător, dacă POT INTRA AMBII COPII sau INTRA PE RAND. Exemple : Date de intrare : greutati copii 87 50 Date de ieşire : Intra pe rand Date de intrare 45 52 Date de ieşire Pot intra ambii copii. \n6) Ionel are voie să se uite la TV 20 de ore pe săptămână. Se introduc numărul de ore cât se uită la TV în fiecare zi din săptămână. Să se verifice dacă va fi pedepsit sau nu. Exemplu: Date de intrare: 3 4 2 2 5 6 1 Date de ieşire: Va fi pedepsit. \n7) Să se scrie un program care determină greutatea ideală a unei persoane cunoscând înălţimea, vârsta şi sexul persoanei. Formulele de calcul sunt: Gmasculin = 50 + 0.75 * (inaltime - 150) + (varsta - 20) / 4, Gfeminin = Gmasculin – 10, unde înălţimea este exprimată în cm şi vârsta în ani. Sexul se citeşte sub forma unui caracter, f sau m. Exemplu: Date de intrare: inaltime= 160 varsta=21 sex=f Date de ieşire: greutate= 47.75 kg.\nTestarea câtului sau a restului împărţirii întregi\n1) Se dau trei numere. Să se afişeze aceste numere unul sub altul, afişând în dreptul fiecăruia unul dintre cuvintele PAR sau IMPAR. Exemplu : Date de intrare : 45 3 24 Date de ieşire : 45 impar 3 impar 24 par.\n2) Se dau două numere nenule. Să se verifice dacă primul se împarte exact la al doilea. Exemplu : Date de intrare : 45 7 Date de ieşire : Nu.\n3) Se dau două numere. Să se afişeze acele numere care se împart exact la 7. Exemplu : Date de intrare : 34 28 Date de ieşire : 28.\n4) “Mă iubeşte un pic, mult, cu pasiune, la nebunie, de loc, un pic,…”. Rupând petalele unei margarete cu x petale, el (ea) mă iubeşte …. Exemplu: Date de intrare: x=10 Date de ieşire: … de loc.\n5) La un concurs se dau ca premii primilor 100 de concurenţi, tricouri de culoare albă, roşie, albastră şi neagră, în această secvenţă. Ionel este pe locul x. Ce culoare va avea tricoul pe care-l va primi? Exemplu : date de intrare : x=38 date de ieşire : rosie. \n6) Într-o tabără, băieţii sunt cazaţi câte 4 într-o căsuţă, în ordinea sosirii. Ionel a sosit al n-lea. În a câta căsuţă se va afla? Exemplu : date de intrare : n=69 date de ieşire : casuta 17.\n7) Elevii clasei a V-a se repartizează în clase câte 25 în ordinea mediilor clasei a IV-a. Radu este pe locul x în ordinea mediilor. În ce clasa va fi repartizat (A, B, C, D sau E)?. Exemplu : date de intrare : x=73 date de ieşire : C.\n8) În Galaxia Reckya toate ceasurile au doar 4 ore. Ştiind că Gygely s-a născut la ora 1 şi că va trăi m ore, să se spună la ce oră va muri Gygely. (m\u0026lt;=50). Se dă numărul m. Se cere ora la care va muri Gygely. \nCeasul arată astfel 1 \n4 2 \n3\nExemplu: Date de intrare: m=10 Date de ieşire: 3. (www.contaminare.ro) \nOperatori logici\n1) Se dau trei numere diferite. Să se afişeze cel mai mare şi cel mai mic. Exemplu : Date de intrare 45 34 78 Date de ieşire max=78 min=34.\n2) Se dau trei numere diferite. Afisaţi-le în ordine crescătoare. Exemplu : Date de intrare 4 2 6 Date de ieţire 2 4 6.\n3) Se dau trei numere diferite. Afişaţi numărul a cărei valoare este cuprinsă între valorile celorlalte două. Exemplu : Date de intrare 12 14 10 Date de ieşire 12.\n4) Se introduc trei date de forma număr curent elev, punctaj. Afişaţi numărul elevului cu cel mai mare punctaj. Exemplu : Date de intrare nr crt 7 punctaj 120 nr crt 3 punctaj 100 nr crt 4 punctaj 119 Date de ieşire punctaj maxim are elevul cu nr crt 7.\n5) Se introduc trei numere. Să se verifice dacă formează o secvenţă de numere consecutive. Exemple: Date de intrare 3 4 5 Date de ieşire Da Date de intrare 4 5 7 Date de ieşire Nu.\n6) La ora de matematică Gigel este scos la tablă. Profesoara îi dictează trei numere şi îi cere să verifice dacă cele trei numere pot fi laturile unui triunghi. Ajutaţi-l pe Gigel să afle rezultatul. Scrieţi un program care primeşte numerele lui Gigel, care sunt mai mici ca 32000, şi returnează DA sau NU. Observaţie: Trei numere pot fi laturile unui triunghi numai dacă fiecare este mai mic ca suma celorlalte două. Exemple: Date de intrare 3 5 7 Date de ieşire Da Date de intrare 2 5 9 Date de ieşire Nu. \n7) Să se verifice dacă o literă introdusă este vocală sau consoană. Exemplu : Date de intrare a Date de ieşire vocala.\n8) Se introduc vârstele a 3 persoane. Afişaţi vârstele cuprinse între 18 şi 60 de ani. Exemplu : Date de intrare 56 34 12 Date de ieşire 56 34.\n9) Date două numere, afişaţi acele numere care se împart exact la 7 şi la 11. Exemplu : Date de intrare 154 213 Date de ieşire 154.\n10)Se dau două numere. Să se verifice dacă numărul mai mare se împarte exact la cel mai mic. Exemplu : Date de intrare 10 250 Date de ieşre 250 se imparte exact la 10. \n11)Cunoscând data curentă exprimată prin trei numere întregi reprezentând anul, luna, ziua precum şi data naşterii unei persoane, exprimată la fel, să se facă un program care să calculeze vârsta persoanei respective în număr de ani împliniţi. Exemplu : Date de intrare data curenta 2005 10 25 data nasterii 1960 11 2 Date de ieşre 44 ani. \nProbleme diverse\n1) Andrei primeşte într-o zi trei note, nu toate bune. Se hotărăşte ca, dacă ultima notă este cel puţin 8, să le spună părinţilor toate notele primite iar dacă este mai mică decât 8, să le comunice doar cea mai mare notă dintre primele două. Introduceţi notele luate şi afişaţi notele pe care le va comunica părinţilor. Exemple : Date de intrare 6 9 9 Date de ieşire 6 9 9 ; Date de intrare 8 5 7 Date de ieşire 8.\n2) Se consideră trei numere întregi. Dacă toate sunt pozitive, să se afişeze numărul mai mare dintre al doilea şi al treilea număr, în caz contrar să se calculeze suma primelor două numere. Exemple: Date de intrare 45 23 100 date de ieşire 100 ; Date de intrare 34 -25 10 Date de ieşire 9.\n3) Să se afişeze cel mai mare număr par dintre doua numere introduse în calculator. Exemple : Date de intrare 23 45 Date de ieşire nu exista numar par ; Date de intrare 28 14 Date de ieşire 28 ; Date de intrare 77 4 Date de ieşire 4.\n4) Pe o masă de biliard sunt bile albe, roşii şi verzi. Din fiecare culoare sunt bile de două dimensiuni: mari şi mici. Să se afişeze câte bile sunt în total pe masa de biliard. Un jucător vrea să-i spuneţi care bile sunt mai multe , cele mici sau cele mari, afişând numărul lor. De ce culoare sunt bilele cele mai numeroase? Precizaţi numărul lor. Exemplu: Date de intrare Nr. bile albe mici: 2 Nr. bile albe mari: 3 Nr. bile rosii mici: 1 Nr. bile rosii mari: 4 Nr. bile verzi mici: 3 Nr. bile verzi mari: 4 Date de ieşire Totalul bilelor: 17 Mari: 11 bile Verzi: 7 bile \n(www.contaminare.ro).\n5) La ferma de găini Copanul este democraţie. Fiecare găină primeşte exact acelaşi număr de boabe de porumb. Cele care nu pot fi împărţite vor fi primite de curcanul Clapon. Să se spună cine a primit mai multe boabe şi cu cât. În caz de egalitate, se va afişa numărul de boabe primite şi cuvântul \u0026quot;egalitate\u0026quot;. Datele se vor citi în următoarea ordine: numărul de găini, iar dupa aceea numărul de boabe de porumb. Exemplu: Date de intrare 100 4050 Date de ieşire: Curcanul mai mult cu 10 boabe. (www.contaminare.ro).\nSTRUCTURI REPETITIVE\nSume si produseS1 = 1 – x2/2! + x4/4! – x6/6!+…+(-1)n x2n/(2n)! (expresia conduce la valoarea lui cos(x) )\nS2 = 13 – 33 + 53 - … (n termeni)\nS3 = 12 – 22 + 32 – 42 +…n2 (n dat)\nS4 = 1\u0026frasl;1+ ½ + 1\u0026frasl;3 + … + 1/n (n dat)\nS5 = 1! + 2! + 3! +…+ n! (n dat)\nS6 = x1 + x2 + x3 + …+xn (x,n date)\nS7 = 1*2 + 2*3 + 3*4 + …+ n( n+1) (n dat)\nP1 = x(x+1)(x+2)(x+3)…(x+n) (x,n date)\nP2 = (1 – 1\u0026frasl;22)(1 – 1\u0026frasl;32)…(1 – 1/n2) \nP3 = (x-2)(x-4)(x-8)…(x-64) / (x-1)(x-3)(x-7)…(x-63), (x dat)\nn!=1*2*3…*n (n factorial)\nDivizibilitatea) Numere prime:\n2.1 Generati primele n numere prime\n2.2 Determinati numerele prime din intervalul [a,b]\n2.3 Determinati factorul prim care apare la puterea cea mai mare in descompunerea lui N in factori primi\n2.4 Descompuneti numarul N in factori primi\n2.5 Determinati la ce putere apare 2 in descompunerea lui N in factori primi\n2.6 Verificati daca N este superprim (el si toate prefixele sale sunt numere prime)\n2.7 Afisati toate numerele prime mai mici sau egale cu N care citite invers sunt tot numere prime\n2.8 Descompuneti N in suma de numere prime, fara a repeta numerele in descompunere\n2.9 Doua numere prime impare consecutive se numesc prime gemene. Determinati perechile de numere prime gemene mai mici sau egale cu K\nb) Divizori\n2.10 Verificati daca N este perfect (egal cu suma divizorilor sai fara el insusi)\n2.11 Determinati numerele de forma abcd divizibile cu N dat. Cifrele vor fi distincte 2 cate 2\n2.12 Determinati cmmdc, cmmmc a 2 numere ( cmmmc (a,b) = a*b/cmmdc(a,b) )\n2.13 Determinati toti divizorii comuni a 2 numere\n2.14 Determinati cel mai mic numar mai mic sau egal cu N care are numar maxim de divizori proprii\n2.15 Determinati cel mai mic si cel mai mare divizor propriu al lui N\n3 Prelucrarea cifrelor unui numar\n3.1 Care sunt numerele de 3 cifre cu produsul cifrelor egal cu o valoare P data.\n3.2 Se citesc N numere. Cu cati de zero se termina produsul lor (fara a determina produsul). \nCare este ultima cifra a sumei lor (fara a calcula suma)\n3.3 Determinati numerele de doua cifre cu proprietatea: rasturnatul patratului numarului este egal cu patratul numarului rasturnat\n3.4 Pentru N dat afisati cifrele care apar in componenta sa si frecventa lor de aparitie\n3.5 Pentru N dat afisati cel mai mare numar obtinut prin eliminarea unei cifre\n3.6 Afisati prefixele si sufixele unui numar N\n3.7 Determinati numarul obtinut fara cifra (cifrele) din mijloc (N-dat)\n3.8 Determinati numarul obtinut din N fara prima si ultima sa cifra\n3.9 De cate ori apare cifra c in numerele mai mici sau egale decat N dat\n3.10 Determinati cifra de rang k din N (de la dreapta la stanga si de la stanga la dreapta)\n3.11 Verificati daca un numar N e “bine ordonat” (cifrele sale citite de la dreapta la stanga \nsunt sau in ordine crescatoare, sau numai descrescatoare)\n3.12 Cate cifre se obtin prin alaturarea numerelor 1,2,…n\n3.13 Se dau n cifre (n mai mic sau egal cu 9). Construiti numarul obtinut din aceste cifre (de \nla stanga la dreapta si apoi de la dreapta la stanga)\n3.14 Pentru numarul N dat, construiti numarul obtinut prin eliminarea cifrelor sale pare\n3.15 Determinati produsul interior al unui numar (produsul cifrelor sale, fara prima si fara ultima sa cifra)\n4 Prelucrarea numerelor dintr-un interval\n4.1 Afisati elementele din intervalul [a;b] care sunt divizibile cu k (a,b,k date)\n4.2 Afisati elementele din intervalul [a;b] care il divid pe k (a,b,k date)\n4.3 Afisati elementele din intervalul [a;b] care au cifra zecilor mai mica decat cifra unitatilor (a,b date)\n4.4 Cate numere din intervalul [a;b] sunt numere prime ?\n4.5 Afisati numerele mai mici decat n care au ultima cifra 3 (n dat) \nex. n=128 =\u0026gt; 3, 13, 23, 33, 43, 53, 63, 73, 83, 93, 103, 113, 123\n4.6 Dintre numerele mai mici ca n, afisati-le pe cele care sunt “echilibrate” (au prima cifra egala cu ultima)\n5 Probleme care prelucreaza n numere\n5.1 Se citesc n numere. Determinati maximul, minimul dintre ele si cu ce cifra se termina produsul dintre maxim si minim\n5.2 Se citesc n numere. Cate sunt pare, cate impare si cate au exact o cifra?\n5.3 Se citesc n numere. Determinati suma S2a numerelor de pe pozitii pare (al doilea, al patrulea, etc) precum si suma S1 a numerelor de pe pozitii impare\n5.4 Se citesc n numere. Determinati media aritmetica a numerelor nenule citite.\n5.5 Se citesc n numere. Cate sunt mai mari decat zero, cate egale cu zero si cate mai mici decat zero, precum si procentul reprezentat de acestea din numarul total de numere.\n5.6 Se citesc n numere reprezentand notele la BAC ale unui absolvent. Sa se calculeze media si sa se precizeze daca e admis sau nu (e admis daca fiecare nota e cel putin 5, iar media generala e cel putin 6)\n6 Diverse\n6.1 Afisati sirul de valori: 1 12 123 1234 …123…n\n6.2 Verificati daca N e numar Fibonacci. Daca nu, descompuneti-l in mod unic in suma de numere Fibonacci.\n6.3 Determinati elementul de pe pozitia K din sirul 1,2,2,3,3,3…\n6.4 Generati progresia aritmetica (geometrica) de prim termen a si ratie r, cu n termeni (a, r, n date)\n6.5 Determinati toate reprezentarile lui n in suma de numere naturale consecutive\n6.6 Se citesc numere pana la tastarea lui 0. Care sunt cele mai mici 2 elemente ? \n6.7 Afisati primii n termeni din sirul lui Fibonacci: 1,1,2,3,5,8…(n dat)\n6.8 Afisati patratele perfecte mai mici ca n (n dat) – ex. n=54 =\u0026gt; 1, 4, 9, 16, 25, 36, 49 \n6.9 Afisati cuburile perfecte mai mici ca n (n dat) – ex. n=54 =\u0026gt; 1, 8, 27\n6.10 Afisati primele k patrate perfecte (k dat) – ex. k=5 =\u0026gt; 1, 4, 9, 16, 25\n6.11 Se dau 2 numere n si b. Verificati daca n este corect in baza b (cifrele lui n sa fie mai \nmici ca b). Daca da, sa se determine alt numar x reprezentand conversia lui n din baza b \nin baza 10.\n6.12 Se da un numar n considerat in baza 10 si se mai da un numar b mai mic ca 10. Scrieti \nprogramul care determina alt numar x reprezentand conversia lui n in baza b.\n6.13 Se citeste un numar natural n. Determinati cele doua patrate perfecte intre care este \nsituat n. Ex. n = 27 =\u0026gt; 25 si 36\n6.14 Verificati daca N e putere a lui 2 \nProbleme folosind structurile repetitive(care se bazează pe prelucrarea cifrelor unui număr) 1. (Sufixele unui număr) Se citeşte un număr natural nenul n, de maxim 8 cifre, de la tastatură. Scrieţi un program C++ care determină şi afişează toate sufixele numărului natural citit iniţial.(sufixele unui număr se obţin prin eliminarea repetată a ultimei cifre)\n2. (Câte cifre pare, câte cifre impare) Se citeşte un număr natural nenul n, de maxim 8 cifre, de la tastatură. Scrieţi un program C++ care determină şi afişează câte cifre pare şi câte cifre impare există în numărul citit iniţial. Dacă numărul citit iniţial e format: doar din cifre pare atunci se va afişa mesajul „Nu există cifre impare” doar din cifre impare atunci se va afişa mesajul „Nu există cifre pare”\n3. (Media aritmetică a cifrelor pare) Se citeşte un număr natural nenul n, de maxim 8 cifre, de la tastatură. Scrieţi un program C++care determină şi afişează cifrele pare ale numărului citit iniţial, apoi calculează şi afişează media aritmetică a cifrelor pare din numărul citit iniţial.\n4. (Cifra de rang k) Se citeşte un număr natural nenul n, de maxim 8 cifre, de la tastatură şi o valoarea naturală din intervalul [1,8], în variabila k. Scrieţi un program Pascal care determină şi afişează cifra de rang k din numărul n citit iniţial(rangul unei cifre se determină de la dreapta spre stânga).\n5. (Căutarea unei cifre) Se citeşte un număr natural nenul n, de maxim 8 cifre, de la tastatură şi o valoarea naturală din intervalul [0,9], în variabila c. Scrieţi un program C++ care verifică dacă cifra c există cel puţin o dată în numărul citit iniţial. Dacă cifra există se va afişa mesajul „EXISTĂ”, în caz contrar se va afişa mesajul „NU EXISTĂ”.\n6. (Număr de apariţii a unei cifre) Se citeşte un număr natural nenul n, de maxim 8 cifre, de la tastatură şi o valoarea naturală din intervalul [0,9], în variabila c. Scrieţi un program C++ care determină numărul de apariţii a cifrei c în numărul citit iniţial. Dacă cifra căutată nu există atunci se va afişa mesajul „NU EXISTĂ”, în caz contrar se va afişa numărul de apariţii a cifrei c în numărul n.\n7. (Cifra minimă) Se citeşte un număr natural nenul n, de maxim 8 cifre, de la tastatură. Scrieţi un program C++ care determină şi afişează cifra minimă din numărul citit iniţial.\n8. (Cifra maximă) Se citeşte un număr natural nenul n, de maxim 8 cifre, de la tastatură. Scrieţi un program C++ care determină şi afişează cifra maximă din numărul citit iniţial.\n9. (Numărul cifrelor multiplii de m) Se citeşte un număr natural nenul n, de maxim 8 cifre, de la tastatură şi o valoarea naturală din intervalul [1,9], în variabila m. Scrieţi un program C++ care determină şi afişează câţi multiplii de m există în numărul citit iniţial.\n10. (Construcţia oglinditului unui număr) Se citeşte un număr natural nenul n, de maxim 8 cifre, de la tastatură. Scrieţi un program C++ care construieşte şi afişează oglinditul numărului citit iniţial.\n11. (Număr palindrom) Se citeşte un număr natural nenul n, de maxim 8 cifre, de la tastatură. Scrieţi un program C++ care verifică dacă numărul citit iniţial este număr palindrom. (nu număr se numeşte palindrom dacă numărul iniţial este identic cu oglinditul său)\n12. (Permutările circulare e ultimei cifre) Se citeşte un număr natural nenul n, de maxim 8 cifre, de la tastatură. Scrieţi un program C++ care construieşte şi afişează toate numerele obţinute prin permutarea circulară a ultimei cifre din număr.\n13. (Eliminarea cifrelor pare) Se citeşte un număr natural nenul n, de maxim 8 cifre, de la tastatură. Scrieţi un program C++care construieşte şi afişează numărul obţinut prin eliminarea cifrelor pare din numărul citit iniţial. Dacă numărul nu conţine nicio cifră pară se va afişa mesajul „Nimic de eliminat!”.\n14. (Eliminarea cifrelor impare) Se citeşte un număr natural nenul n, de maxim 8 cifre, de la tastatură. Scrieţi un program C++care construieşte şi afişează numărul obţinut prin eliminarea cifrelor impare din numărul citit iniţial. Dacă numărul nu conţine nicio cifră impară se va afişa mesajul „Nimic de eliminat!”.\n15. (Inserarea unei cifre) Se citeşte un număr natural nenul n, de minim 2 cifre şi maxim 8 cifre, de la tastatură şi o valoarea naturală din intervalul [0,9], în variabila c. Scrieţi un program C++ care construieşte un nou număr prin inserarea cifrei c în mijlocul numărului citit iniţial.\nProbleme suplimentare\n16. (Nr. format din cifre pare) Se citeşte un număr natural nenul n, de maxim 8 cifre, de la tastatură. Scrieţi un program C++ care determină şi afişează numărul format doar din cifrele pare a numărul citit iniţial. Dacă numărul citit iniţial e format doar din cifre impare atunci se va afişa mesajul „Nu există cifre pare”.\n17. (Nr. format din cifre impare) Se citeşte un număr natural nenul n, de maxim 8 cifre, de la tastatură. Scrieţi un program C++ care determină şi afişează numărul format doar din cifrele impare a numărul citit iniţial. Dacă numărul citit iniţial e format doar din cifre pare atunci se va afişa mesajul „Nu există cifre impare”.\n18. (Cifra de rang par) Se citeşte un număr natural nenul n, de maxim 8 cifre, de la tastatură. Scrieţi un program C++ care determină şi afişează cifrele de rang par din numărul n citit iniţial(rangul unei cifre se determină de la dreapta spre stânga).\n19. (Cifra de rang impar) Se citeşte un număr natural nenul n, de maxim 8 cifre, de la. Scrieţi un program C++ care determină şi afişează cifrele de rang impar din numărul n citit iniţial(rangul unei cifre se determină de la dreapta spre stânga).\n20. (Minimul şi maximul dintr-o singură parcurgere a cifrelor) Se citeşte un număr natural nenul n, de maxim 8 cifre, de la tastatură. Scrieţi un program C++ care determină şi afişează cifra minimă şi cifra maximă din numărul citit iniţial, printr-o singură prelucrare a cifrelor numărului.\n21. (Cifra maximă pară şi impară) Se citeşte un număr natural nenul n, de maxim 8 cifre, de la tastatură. Scrieţi un program C++ care determină şi afişează cifra maximă pară şi impară din numărul citit iniţial, printr-o singură prelucrare a cifrelor numărului.\n22. (Cifra minimă pară şi impară) Se citeşte un număr natural nenul n, de maxim 8 cifre, de la tastatură. Scrieţi un program C++ care determină şi afişează cifra minimă pară şi impară din numărul citit iniţial, printr-o singură prelucrare a cifrelor numărului.\n23. (Număr de apariţii a cifrei minime) Se citeşte un număr natural nenul n, de maxim 8 cifre, de la tastatură. Scrieţi un program C++ care determină şi afişează numărul de apariţii a cifrei minime din numărul citit iniţial.\n24. (Număr de apariţii a cifrei maxime) Se citeşte un număr natural nenul n, de maxim 8 cifre, de la tastatură. Scrieţi un program C++ care determină şi afişează numărul de apariţii a cifrei maxime din numărul citit iniţial.\n25. (Cel mai mare număr) Se citeşte un număr natural nenul n, de maxim 8 cifre, de la tastatură. Scrieţi un program C++care determină şi afişează cel mai mare număr format cu ajutorul cifrelor numărului natural citit iniţial.\n26. (Cel mai mic număr) Se citeşte un număr natural nenul n, de maxim 8 cifre, de la tastatură. Scrieţi un program C++care determină şi afişează cel mai mic număr format cu ajutorul cifrelor numărului natural citit iniţial.\n27. (Cifre egale, identice) Se citeşte un număr natural nenul n, de maxim 8 cifre, de la tastatură. Scrieţi un program C++care verifică dacă cifrele numărului n sunt identice. Dacă cifrele sunt egale între ele se va afişa mesajul „EGALE”, altfel se va afişa mesajul „NU”.\n28. (Cifre distincte) Se citeşte un număr natural nenul n, de maxim 8 cifre, de la tastatură. Scrieţi un program C++ care verifică dacă cifrele numărului n sunt toate distincte. Dacă cifrele sunt distincte se va afişa mesajul „DISTINCTE”, altfel se va afişa mesajul „NU”.\n29. (Câte cifre distincte) Se citeşte un număr natural nenul n, de maxim 8 cifre, de la tastatură. Scrieţi un program C++ care numără câte cifre distincte are numărul citit iniţial. Dacă toate cifrele sunt distincte atunci se va afişa mesajul „DISTINCTE”, altfel se va afişa numărul de apariţii a fiecărei cifre distincte.\n30. (Cifre comune) ) Se citesc două numere naturale nenul n şi m, de maxim 8 cifre, de la tastatură. Scrieţi un program C++ care numără şi afişează câte cifre comune au cele două numere.   \n"
},
{
	"uri": "https://danielanicolae.com/programare/subiecte_atestat/",
	"title": "Subiecte Atestat",
	"tags": [],
	"description": "",
	"content": "  SUBIECTE_ATESTAT_INFORMATICA_2016 (1).pdf\nhttp://www.itlearning.ro/tutorials/tutorial\nhttp://www.officespecialist.ro/\nhttp://www.drexcel.ro/\ntutoriale Word\nModele subiecte competente digitale  http://www.competentedigitale.ro/\naici SI AICI COMPETENTE 2009-2010.rarSI AICI COMPETENTE2 2009-2010.rarSI AICI COMPETENTE3 2009-2010.rar Olivia Pascu\nhttp://www.test-e.ro/\nprima culegere de Tehnologia Informatiilor si a Comunicatiilor în format electronic, ttest-eTIC\naccess\n Tipuri De Date Si Proprietati from Lavric   \n"
},
{
	"uri": "https://danielanicolae.com/programare/subprograme/",
	"title": "Subprograme",
	"tags": [],
	"description": "",
	"content": "  PREZENTARE TEORETICA\n1. Introducere Subprogramele sunt părţi ale unui program, identificabile prin nume, care se pot activa la cerere prin intermediul acestor nume.Prezenţa subprogramelor implică funcţionarea în strânsă legătură a două noţiuni: definiţia unui subprogram şi apelul unui subprogram.Definiţia unui subprogram reprezintă de fapt descrierea unui proces de calcul cu ajutorul variabilelor virtuale (parametri formali) iar apelul unui subprogram nu este altceva decât execuţia procesului de calcul pentru cazuri concrete (cu ajutorul parametrilor reali, (efectivi, actuali) ).2. Structura unui subprogram C++Un subprogram (funcţie) are o definiţie şi atâtea apeluri câte sunt necesare.\nDefiniţia unei funcţii are forma generală:\ntip_returnat nume_funcţie (lista parametrilor formali)\n{\ninstrucţiune; // corpul funcţiei\n}\n Tip_returnat\n Reprezintă tipul rezultatului calculat şi returnat de funcţie şi poate fi: int, char, char*, long, float, void, etc.\nÎn cazul în care tipul rezultatului este diferit de void, corpul funcţiei trebuie să conţină cel puţin o instrucţiune return.\nÎnstrucţiunea return va specifica valoarea calculată şi returnată de funcţie care trebuie să fie de acelaşi tip ca şi tip_returnat.\n   Nume_funcţie\n Reprezintă numele dat funcţiei de către cel ce o defineşte, pentru a o putea apela.\n   Lista_parametrilor_formali\n Reprezintă o listă de declaraţii de variabile separate prin virgulă. Această listă poate să fie şi vidă.\n   Instrucţiune\n Este o instrucţiune vidă, simplă sau compusă.\n   \n3. Apelul unei funcţii . Revenirea dintr-o funcţie  3.1 Apelul unei funcţii care nu returnează o valoare are forma generală:\nnume_funcţie (lista parametrilor efectivi);\nunde:\nparametru efectiv = parametru actual = parametru real = parametru de apel lista parametrilor efectivi = poate fi vidă, poate fi o expresie sau mai multe despărţite prin virgulă\nEfectul instructiunii de apel este:\ncrearea tabelei de parametrii actuali;crearea variabilelor locale functiei;executarea corpului de instructiuni al functiei;desfintarea tabelei de parametrii si a variabilelor locale;revenirea la instruciunea urmatoare din programO funcţie care returnează o valoare poate fi apelată fie printr-o instrucţiune de apel simplă (cazul funcţiilor care nu returnează valori) şi în plus poate fi apelată ca operand al unei expresii. În cazul în care funcţia se apelază print-o instrucţiune de apel simplă, rezultatul funcţiei se pierde.\nCând funcţia se apelează ca operand, valoarea returnată va fi utilizată în expresie. \nLa apelul unei funcţii, valorile parametrilor efectivi se atribuie parametrilor formali corespunzători. În cazul în care unul din tipul unui paramatru efectiv diferă de tipul parametrului formal corespunzător, parametrul efectiv va fi convertit spre parametru formal (dacă este posibil, altfel compilatorul generează eroare). \nÎn momentul în care se întâlneşte un apel de funcţie, controlul execuţiei programul este transferat primei instrucţiuni din funcţie, urmând a se executa secvenţial instrucţiunile funcţiei.\nRevenirea dintr-o funcţie se face în unul din următoarele cazuri: \ndupă execuţia ultimei instrucţiuni din corpul funcţiei la întâlnirea unei instrucţiuni return Instrucţiunea return \nare formatele:\nreturn ; return expresie ; \n Exemplul 3.1 \n Exemplul 3.2 \n   include \u0026lt;iostream\u0026gt;using namespace std;\nvoid f1 ()\n{\ncout \u0026lt;\u0026lt; \u0026quot;abc\u0026quot;;\n}\nint main ()\n{\nf1();\n}\n #include \u0026lt;iostream\u0026gt;\nusing namespace std;\nvoid f1 (int k)\n{\nfor (int i=1; i\u0026lt;=k ; i++)\ncout \u0026lt;\u0026lt; \u0026quot;abc\u0026quot;\u0026lt;\u0026lt; \u0026quot; \u0026quot;;\n}\nint main ()\n{\nf1(5);\n}\n   Se va afisa:abc\n Se va afişa:abc abc abc abc abc\n   Funcţia nu returnează o valoareFuncţia nu are parametriApelul funcţiei este o instrucţiune de apel simplă\n Funcţia nu returnează o valoareFuncţia are un parametru formal de tip intApelul funcţiei este o instrucţiune de apel simplă şi se face cu ajutorul unui parametru actual care este de acelaşi tip cu tipul parametrului formal corespunzător\n   \n Exemplul 3.3 \n Exemplul 3.4 \n   #include \u0026lt;iostream\u0026gt;\nusing namespace std;\nint prim (int x)\n{int nr_div;\nnr_div=0;\nfor (int i=2; i\u0026lt;=x/2; i++)\nif (x%i==0)\nnr_div++;\nif (nr_div==0)\nreturn 1;\nelse\nreturn 0;\n}\nint main ()\n{int N;\ncout \u0026lt;\u0026lt; \u0026quot;N=\u0026quot;; cin \u0026gt;\u0026gt; N;\nif (prim(N))\ncout \u0026lt;\u0026lt; \u0026quot;PRIM\u0026quot;;\nelse\ncout \u0026lt;\u0026lt; \u0026quot;NU E PRIM\u0026quot;;\n}\n include \u0026lt;iostream\u0026gt;\nusing namespace std;\nint prim (int x)\n{int i;\nfor ( i=2; i\u0026lt;=x/2; i++)\nif (x%i==0)\nreturn 0;\nreturn 1;\n}\nint main ()\n{int N;\ncout \u0026lt;\u0026lt; \u0026quot;N=\u0026quot;; cin \u0026gt;\u0026gt; N;\nif (prim(N))\ncout \u0026lt;\u0026lt; \u0026quot;PRIM\u0026quot;;\nelse\ncout \u0026lt;\u0026lt; \u0026quot;NU E PRIM\u0026quot;;\n}\n   Funcţia returnează o valoare de tip int Funcţia are un parametru formal de tip int Rezultatul funcţiei este este utilizat în cadrul unei expresii.\n În cazul în care se întâlneşte un divizor a lui x se execută instrucţiunea return 0. Astfel apelul funcţiei se încheie. \nDacă x este număr prim, instrucţiunea return 0 nu se execută niciodată şi în acest caz, după terminarea execuţiei instrucţiunii for, se execută instrucţiunea return 1 (care determină încheierea execuţiei funcţiei).\n   OBS: În cazul în care tipul returnat de funcţie lipseşte din definiţia funcţiei, acesta este implicit \nint şi nu void.\n Exemplul 3.5\n Exemplul 3.6\n Exemplul 3.7\n   #include \u0026lt;iostream\u0026gt;\nusing namespace std;\np( )\n{\ncout \u0026lt;\u0026lt; \u0026quot; abcd\u0026quot;;\n}\nint main ()\n{\ncout \u0026lt;\u0026lt; p();\n}\n #include \u0026lt;iostream\u0026gt;\nusing namespace std;\np( )\n{\nreturn 25;\n}\nint main ()\n{\ncout \u0026lt;\u0026lt; p( );\n}\n #include \u0026lt;iostream\u0026gt;\nusing namespace std;\nvoid p( )\n{\ncout \u0026lt;\u0026lt; \u0026quot;void\u0026quot;;\n}\nint main ()\n{\ncout \u0026lt;\u0026lt; p();\n}\n   Compilatorul generează eroare deoarece lipseste tipul returnat de functie\n Compilatorul generează eroare deoarece lipseste tipul returnat de functie\n Compilatorul generează eroare deoarece o functie cu tipul returnatvoidnu se poate apela in cadrul unei functii, in cazul de fata cout\n   \n #include \u0026lt;iostream\u0026gt;\nusing namespace std;\nint p( )\n{\nreturn 25;\n}\nint main ()\n{\ncout \u0026lt;\u0026lt; p( );\n}\n #include \u0026lt;iostream\u0026gt;\nusing namespace std;\nvoid p( )\n{\ncout \u0026lt;\u0026lt; \u0026quot;abcd\u0026quot;;\n}\nint main ()\n{\np();\n}\n   \n Se afişează 25 \n Se afişează abcd\n   4. Prototipul unei funcţii  Pentru a apela o funcţie, aceasta trebuie initial definită. Astfel apelul unei funcţii trebuie precedat de definiţia funcţiei respective. \nO a doua posibilitate de apelare a funcţiei constă în scrierea prototipului funcţiei înainte ca acesta să fie apelată. \nPrototipul funcţiei conţine informaţii asemănătoare cu cele din antetul funcţiei. Pot lipsi numele parametrilor formali (contează doar tipul şi ordinea acestora), în plus acesta este urmat de “;”. \nExemplul 4.1.\n # include \u0026lt;iostream\u0026gt;\nusing namespace std;\nint max (int, int);\nint main ()\n{\ncout \u0026lt;\u0026lt; max(10, 20);\n}\nint max (int a, int b)\n{\nif (a\u0026gt;b)\nreturn a;\nelse\nreturn b;\n}\n PROTOTIPUL FUNŢIEI \nAPELUL FUNCŢIEI\nDEFINIŢIA FUNCŢIEI \nantetul funcţiei \ncorpul functiei\n   5. Variabile locale şi variabile globale \n5.1 . Funcţia main\nÎn C++ funcţia maindetermină prima instrucţiune pe care o va executa programul. Aceasta este unica diferenţă dintre main şi celelalte funcţii. Din acest motiv se poate spune că “orice se poate face în main se poate face şi în celelalte funcţii”.\n5.2. Variabile locale \nLa fel cum se declară variabilele în cadrul funcţiei main, la fel se pot declara varibile si în cadrul celorlalte funcţii. Aceste variabile se numesc locale şi sunt accesibile doar in funcţia in care au fost declarate.\nIn cadrul unei funcţii se pot apela şi alte funcţii, cu conditia ca acestea sa fi fost definite înaintea eventualului apel sau este prezent un prototip de funcţie înaintea funcţiei apelate \n5.3. Variabile globale \nVariabilele globale \nsunt declarate în afara oricărei funcţii şi sunt vizibile (pot fi utilizate) în tot programul (în programul principal şi în subprograme) din momentul declarării lor.\n Exemplul 5.1 \n Exemplul 5.2 \n Exemplul 5.3 \n   include \u0026lt;iostream\u0026gt;using namespace std;\nint N;\nvoid f1()\n{\nint x=5;\nN=10;\ncout \u0026lt;\u0026lt; endl\u0026lt;\u0026lt;N;\ncout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; x;\n}\nint main ()\n{\nN=4;\ncout \u0026lt;\u0026lt; N;\nf1();\n}\n include \u0026lt;iostream\u0026gt;using namespace std;\nint N;\nvoid f1()\n{\nint x=5;\ncout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; x;\nP=2; \n}\nint P=9;\nint main ()\n{f1();\ncout \u0026lt;\u0026lt; x;\nP=7; \n}\n include \u0026lt;iostream\u0026gt;using namespace std;\nint N;\nvoid f1(int p)\n{\nint x=p;\ncout \u0026lt;\u0026lt; x;\n}\nint main ()\n{\nf1(77);\n}\n   N este variabilă globală si poate fi accesată în cadrul oricărei funcţii. \nx este variabilă locală, vizibilă doar în cadrul funcţiei f1() \nSe va afişa: \n4 \n10 \n5 \n Compilatorul generează eroare deoarece \nfuncţia main încearcă să acceseze variabila locala x care este vizibilă doar în funcţia f1(). variabila P este accesată în f1() înainte de a fi declarată. Se afişează 77 \nN este variabilă globală. Poate fi accesată în cadrul oricărei funcţii. \nx este variabilă locală. Poate fi accesată doar în cadrul funcţiei f1() \np este parametru formal. Poate fi accesat doar în f1(). \n   5.4. Regula de omonimie \nÎn cazul în care există o variabilă locală care are acelaşi nume cu o variabilă globală, aceste două variabile se numesc variabile omonime.\nVariabilele locale sunt prioritare (ascund) variabilele globale omonime.\n Exemplul 5.4\n   include \u0026lt;iostream\u0026gt;using namespace std;\nint N=10;\nvoid f1()\n{\nint N=2;\ncout \u0026lt;\u0026lt; N\u0026lt;\u0026lt;\u0026quot; \u0026quot;;\n}\nint main ()\n{\nf1();\ncout \u0026lt;\u0026lt; N;\n}\n Variabila N este definită atât ca variabilă globală cât şi ca variabilă locală în f1().\nSe va afisa: 2 10\nFuncţia f1() acţionează asupra variabilei locale N.\nFuncţia main() acţionează supra variabilei globale N.\n   \nÎntrebare. Cum gestionează compilatorul cele două variabile omonime ?\nRăspuns:\nVariabilelor globale li se rezervă spaţiu de memorie la începutul execuţiei programului, într-o zonă de memorie numită “zonă de date”. Acest spaţiu va fi ocupat până la încheierea execuţiei programului.\nVariabilelor locale li se rezervă spaţiu într-o zonă specială de memorie numită “stiva”. La încheierea execuţiei subprogramului, conţinutul stivei este eliberat. Din acest motiv, variabilele locale sunt vizibile doar în interiorul subprogramului în care au fost declarate.\n6. Parametrii formali şi parametrii actuali \nParametrii formali apar în antetul subprogramului şi sunt utilizaţi de subprogram pentru descrierea abstractă a unui proces de calcul . \nParametrii actuali apar în instrucţiunea de apelare a uni subprogram şi sunt folosiţi la execuţia unui proces de calcul pentru valori concrete. \nParametrii formali nu sunt variabile. O variabilă este caracterizată de nume, tip, şi adresă. Legarea unui parametru formal la o adresă se realizează în timpul execuţiei instrucţiunii de apelare a subprogramului.\n7. Apel prin valoare şi apel prin referinţă\nExistă două tipuri de apel al subprogramelor: \nApel prin valoare Apel prin referinţă 7.1. Apel prin valoare – se transmite o copie a parametrului actual. \nValorile transmise la apelul unui subprogram sunt memorate în stivă. Datorită faptului că, după terminarea execuţiei unui subprogram, stiva este eliberată, în cazul apelului prin valoare parametrul actual nu se modifică (se operează asupra unei copii a parametrului efectiv) \nParametrii transmisi prin valoare se pot modifica in corpul functiei dar dupa terminarea apelului functiei au aceasi valoare pe care au avut-o inainte de apel.\nSe utilizează atunci când dorim ca subprogramul să lucreze cu acea valoare, dar să nu poată modifica parametrul efectiv corespunzător din blocul apelator.\nSe pot transmite prin valoare:\na)Valorile reţinute de variabile. În acest caz parametrii efectivi trebuie să fie numele variabilelor.\nExemplu:\n#include\u0026lt;iostream.h\u0026gt;\nvoid test(int n)\n{\nn++;\ncout\u0026lt;\u0026lt;n\u0026lt;\u0026lt;endl; tipăreşte n=8\n}\nvoid main()\n{\nint n=7;\ntest(n);\ncout\u0026lt;\u0026lt;n\u0026lt;\u0026lt;endl;  tipăreşte n=7\n}\nParametrul n este transmis prin valoare. În funcţia main() acest parametru este iniţializat cu valoarea 7. Când apelăm funcţia test(), se rezervă spaţiu pe stivă, spaţiu care are numele parametrului formal (în acest caz, tot n) şi care este iniţializat cu valoarea memorată de variabila n a programului principal. Altfel spus, pe stivă se copie valoarea parametrului efectiv de apel. În funcţie, variabila n (care este locală acestei funcţii) este incrementată şi devine 8, valoare care va fi tipărită. La ieşirea din funcţie, variabila n din stivă se pierde, adică nu mai are spaţiu alocat, prin urmare valoarea 8 este pierdută. În main() se tipăreşte valoarea variabilei n (locală acesteia) care are valoarea 7.\nSe observă că, în momentul apelului funcţiei test(), pe stivă sunt alocate două variabile cu acelaşi nume n. Prima variabilă este variabila locală funcţiei main() care se salvează pe stivă în momentul apelului pentru a putea reface contextul funcţiei main() după încheierea apelului. A doua variabilă este parametrul formal tip valoare n, vizibil numai în funcţia test() şi iniţializat în momentul apelului cu valoarea 7. Indiferent ce valori primeşte acest n în corpul funcţiei test(), după încheierea execuţiei acestei funcţii, spaţiul său este de alocat din stivă, adică variabila respectivă este distrusă. Din acest motiv, după execuţia funcţiei test(), conţinutul stivei este cel din dreapta. Se reface contextul din care s-a lansat apelul funcţiei test(), adică se recuperează din stivă valoarea variabilei locale n=7 şi adresa de revenire, adică adresa instrucţiunii cout.\nb) Expresii. În acest caz, parametrii efectivi sunt expresii, care pot conţine şi funcţii şi care mai întâi se evaluează. Exemplu:\n#include\u0026lt;iostream.h\u0026gt;\n#include\u0026lt;math.h\u0026gt;\nvoid test(int n)\n{\ncout\u0026lt;\u0026lt;n\u0026lt;\u0026lt;endl;\n}\nvoid main()\n{\ntest(5); se va tipări 5\ntest(7+(int)sqrt(45));  se va tipări 13\n}\nÎn funcţie se creează o variabilă numităn, reţinută pe stivă, care la primul apel va primi valoarea 5 şi la al doilea apel valoarea 13.\nLa ieşirea din funcţie conţinutul acestei variabile se pierde.\nTransmiterea parametrilor prin valoarese utilizează când nu dorim ca subprogramul apelat să poată modifica parametrii efectivi de apel. Acesta este modul implicit de transmitere a parametrilor în limbajul C. Dacă nu ar exista decât transmiterea prin valoare, ar fi imposibil să modificăm valoarea anumitor valori care sunt declarate în blocul apelator.\n7.2. Apel prin referinţă - se transmite adresa parametrului actual.\nÎn cazul apelului prin referinţă, subprogramul, cunoscând adresa parametrului actual, acţionează direct asupra locaţiei de memorie indicată de aceasta, modificând valoarea parametrului actual. \nParametrii transmisi prin referinta se folosesc pentru transmiterea de rezultate in afara functiei. Ei se pot modifica in corpul functiei dar dupa terminarea apelului functiei au valoarea pe care au primit-o in timpul apelului functiei.\nÎn C++, implicit, apelul se face prin valoare. Pentru a specifica un apel prin referinţă, în lista parametrilor formali, numele parametrului formal va trebui precedat de simbolul \u0026amp;\n #include \u0026lt;iostream\u0026gt;\nusing namespace std;\nint a,b;\nvoid afis(int a, int b)\n{\na=a+1;\nb=b+4;\ncout\u0026lt;\u0026lt;a\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;b\u0026lt;\u0026lt;endl;\n}\nint main()\n{\na=1;\nb=2;\nafis(a,b);\ncout \u0026lt;\u0026lt;a\u0026lt;\u0026lt;\u0026quot; \u0026quot; \u0026lt;\u0026lt;b\u0026lt;\u0026lt; endl;\n}\n \n #include \u0026lt;iostream\u0026gt;\nusing namespace std;\nint a,b;\nvoid afis(int \u0026amp;a, int \u0026amp;b)\n{\na=a+1;\nb=b+4;\ncout\u0026lt;\u0026lt;a\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;b\u0026lt;\u0026lt;endl;\n}\nint main()\n{\na=1;\nb=2;\nafis(a,b);\ncout \u0026lt;\u0026lt;a\u0026lt;\u0026lt;\u0026quot; \u0026quot; \u0026lt;\u0026lt;b\u0026lt;\u0026lt; endl;\n}\n \n #include \u0026lt;iostream\u0026gt;\nusing namespace std;\nint a,b;\nvoid afis(int \u0026amp;m, int n)\n{\nm=m+1;\nn=n+4;\ncout\u0026lt;\u0026lt;m\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;n\u0026lt;\u0026lt;endl;\n}\nint main()\n{\na=1;\nb=2;\ncout \u0026lt;\u0026lt;a\u0026lt;\u0026lt;\u0026quot; \u0026quot; \u0026lt;\u0026lt;b\u0026lt;\u0026lt; endl;\nafis(a,b);\ncout \u0026lt;\u0026lt;a\u0026lt;\u0026lt;\u0026quot; \u0026quot; \u0026lt;\u0026lt;b;\n}\n   Se va afisa:\n2 6 (rezultatul apelului functiei afis)\n1 2 (rezultatul de dupa apelul functiei afis)\n \n Se va afisa:\n2 6 (rezultatul apelului functiei afis)\n2 6 (rezultatul de dupa apelul functiei afis)\n \n Se va afisa:\n1 2 (rezultatul inaintea apelului functiei afis)\n2 6 (rezultatul apelului functiei afis)\n2 2 (rezultatul de dupa apelul functiei afis: variabila a isi pastreaza\nvaloarea dupa apel fiind parametru transmis prin referinta pe cand\nvariabila b revine la valoarea pe care o avea inainte de apel fiind\nparametru transmis prin valoare)\n   \n Exemplul 7.1 \n   include \u0026lt;iostream\u0026gt;using namespace std;\nvoid schimba_valoare (int x, int y)\n{\nint z=x;\nx = y;\ny = z;\n}\nvoid schimba_referinta (int \u0026amp;a, int \u0026amp;b)\n{\nint aux=a;\na=b;\nb=aux;\n}\nint main ()\n{\nint M=1, N=5;\nschimba_valoare(M,N);\ncout \u0026lt;\u0026lt; \u0026quot;M=\u0026quot;\u0026lt;\u0026lt;M\u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; \u0026quot;N=\u0026quot;\u0026lt;\u0026lt;N\u0026lt;\u0026lt;endl;\nschimba_referinta(M,N);\ncout \u0026lt;\u0026lt; \u0026quot;M=\u0026quot;\u0026lt;\u0026lt;M\u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; \u0026quot;N=\u0026quot;\u0026lt;\u0026lt;N\u0026lt;\u0026lt;endl;\n}\n APEL PRIN VALOARE\nAPEL PRIN REFERINŢĂ\nSe va afişa:\nM=1 N=5\nM=5 N=1\n   FISA DE LUCRU 1.doc\nFISE DE LUCRU 3_FISEdincapitolulsubprograme2009_2010.doc\nTESTETEST_SUBPROGRAME.doc\nAPLICATII http://info.mcip.ro/?cap=Subprograme   \n"
},
{
	"uri": "https://danielanicolae.com/programare/tablouri/",
	"title": "Tablouri",
	"tags": [],
	"description": "",
	"content": "  Tablouri c\n\nOperatii cu vectori: Sume produse, numarariMinime si maximeCautariInserariStergeriPermutari circulareFormari de vectori noiOrdonareInterclasareprobleme rezolvate cu vectori.docx\nAPLICATII CU VECTORI v.pdf\nhttp://info.mcip.ro/?cap=TablourI   \n"
},
{
	"uri": "https://danielanicolae.com/programare/tic/",
	"title": "Tehnologia Informatiei si a Comunicatiilor",
	"tags": [],
	"description": "",
	"content": "  DomnulTudor - Tehnologia informatiei si a comunicatiilor    Arhitectura unui sistem de calcul 1arhitectura_sc.pptx Arhitectura unui sistem de calcul 2 prezentareacalculatorului.ppt Sistemul de operare Windows.Operatii cu fisiere5ISTEMUL-DE-OPERARE-WINDOWS.doc FISE DE LUCRU ARHITECTURA SC_SISTEME DE OPERARE ARHITECTURA_SO.rar Internet INTERNET.doc  WORD  EXCEL  POWERPOINT    fisa_de_lucru_tabele2.doc\n test2excel.docx\n 5_aplicatii.doc\n   fisa_de_lucru_tabele.doc\n test1excel.doc\n testcubutoanedeactiune.pdf\n   fise_word.doc\n FISADELUCRU.doc\n FISA_LUCRU_POWERPOINT.doc\n   fisa de lucru word final.doc\n fisadelucru1excel.doc\n power_point.ppt\n   fisa_de_lucru_recapitulativa_word.pdf\n fisaexcel2.doc\n fisadelucrurecapitulativa__ppt.doc\n   word_2007.pdf\n test_evaluare-autoevaluare WORD WXCEL.doc\n Testare Microsoft PowerPoint 2007.docx\n   fisa de evaluare Word.pdf\n testeevaluareexcel.doc\n fisappt_sarbatori.doc\n   \n fisa_de_lucru_excel.pdf\n fisa lucrufinala powerpoint.pdf\n   \n Fisa de lucru3.doc\n fisa_de_lucru_recapitulativa.docx\n   \n fisa_de lucru_4.pdf\n \n   \n Test evaluare excel FINAL.docx\n \n   \n evaluare excel.doc\n \n   NOTEPAD PAINT Lectii online gratuite Microsoft FISA DE EVALUARE TIC_24noiembrie2014.docx   \n"
},
{
	"uri": "https://danielanicolae.com/programare/tipul_struct/",
	"title": "Tipul Struct",
	"tags": [],
	"description": "",
	"content": "  O structura este o colectie de valori eterogene, stocate intr-o zona compacta de memorie.\nComponentele unei structuri, denumite campuri, sunt identificate prin nume simbolice, denumite selectori.\nCampurile unei structuri pot fi de orice tip, simplu sau derivat, dar nu void sau functie.\nDeclararea structurilor se face folosind cuvantul cheie struct:\nstruct [nume_structura]{\ntip1 membrii;\ntip2 membrii;\n\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;.\ntipn membrii;\n}[lista_declaratori]; variabile de tip structura\nnume_structura saulista_declaratori pot lipsi, dar nu simultan.\nDaca se precizeaza nume_structura, atunci inseamna ca se face definirea tipului struct nume_structura, care poate fi apoi folosit pentru declararea de variabile, ca tip de parametri formali sau ca tip de rezultat returnat de functii:\nExemplu1:\nstruct persoana{ se declara tipul struct persoana\nchar nume[20];\nint varsta;\n}; lipseste lista_declaratori\nExemplu2:\nstruct{ lipseste nume_struct\nchar titlu[20],autor[15],editura[12];\nint an_aparitie;\n}carte,biblioteca[1000]; nu se declara un tip, deci\ndoar aici pot fi facute declaratiile de variabile\nUn camp al unei structuri poate fi de tip structura, dar nu aceeasi cu cea definita.\nExemplu3:\nstruct persoana{ se declara tipul struct persoana\nchar nume[20];\nstruct\n{int zi,an,luna;\n} datan; camp de tip structura\n}p;\nExemplu4:\nstruct data{\nint zi,luna,an;};\nstruct persoana{\nchar nume[30];\ndata datan;} p;\nFolosind cuvantul cheie typedef se pot defini tipuri utilizator echivalente pentru cele structura.\nSelectarea unui camp al unei variabile structura se realizeaza folosind operatorul de selectie .. \nCampul selectat se comporta ca o variabila de acelasi tip, deci i se pot aplica aceleasi prelucrari ca oricarei variabile de tipul respectiv.\nvariabila_structura.nume_camp\nExemplu:\npersoana p; //se declara variabila p de tip persoana\np.nume - campul nume din structura persoana\np.datan.an - campul an din data nasterii\np.datan.luna - campul luna din data nasterii\np.datan.zi - campul zi din data nasterii\nAPLICATII\nProbleme rezolvate\n1.Se citesc de la tastatură două numere complexe. Să se efectueze operaţiile de adunare, scadere, înmulţire şi împărţire cu aceste numere complexe. Vom defini tipul structurat complex, care conţine partea reală şi partea imaginară a numărului.\n#include \u0026lt;iostream.h\u0026gt; OPERATII CU NUMERE COMPLEXE\n#include \u0026lt;conio.h\u0026gt;\nstruct complex \nx-partea reala , y-partea imaginara\n{float x,y;\n};\ncomplex a,b,c;\nvoid afisare(complex e) afisarea unui numar complex\n{if(e.y\u0026gt;=0)\ncout\u0026lt;\u0026lt;e.x\u0026lt;\u0026lt;\u0026quot;+\u0026quot;\u0026lt;\u0026lt;e.y\u0026lt;\u0026lt;\u0026quot;i\u0026quot;\u0026lt;\u0026lt;endl;\nelse\ncout\u0026lt;\u0026lt;e.x\u0026lt;\u0026lt;e.y\u0026lt;\u0026lt;\u0026quot;i\u0026quot;\u0026lt;\u0026lt;endl;\n}\nvoid adunare() adunarea a doua numere complexe\n{c.x=a.x+b.x;\nc.y=a.y+b.y;\n}\nvoid scadere() scaderea a doua numere complexe\n{c.x=a.x-b.x;\nc.y=a.y-b.y;\n}\nvoid inmultire() inmultirea a doua nume\n re complexe\n{c.x=a.x*b.y-a.y*b.x;\nc.y=a.x*b.y+a.y*b.x;\n}\nvoid impartire() //impartirea a doua numere complexe\n{c.x=(a.x*b.x+a.y*b.y)/(b.x*b.x+b.y*b.y);\nc.y=(a.y*b.x-a.x*b.y)/(b.x*b.x+b.y*b.y);\n}\nvoid main()\n{cout\u0026lt;\u0026lt;\u0026quot;primul numar:\u0026quot;; cin\u0026gt;\u0026gt;a.x\u0026gt;\u0026gt;a.y;\ncout\u0026lt;\u0026lt;\u0026quot;al doilea numar:\u0026quot;; cin\u0026gt;\u0026gt;b.x\u0026gt;\u0026gt;b.y;\ncout\u0026lt;\u0026lt;\u0026quot;a=\u0026quot;; afisare(a);\ncout\u0026lt;\u0026lt;\u0026quot;b=\u0026quot;; afisare(b);\nadunare();\ncout\u0026lt;\u0026lt;\u0026quot;suma=\u0026quot;;\nafisare\u0026copy;;\n scadere();\ncout\u0026lt;\u0026lt;\u0026quot;diferenta=\u0026quot;;\nafisare\u0026copy;;\ninmultire();\ncout\u0026lt;\u0026lt;\u0026quot;produsul=\u0026quot;;\nafisare\u0026copy;;\nimpartire();\ncout\u0026lt;\u0026lt;\u0026quot;impartire=\u0026quot;;\nafisare\u0026copy;; \ngetch();\n}\n2. Pentru n elevi se citesc: numele şi două note la informatică. Să se calculeze media fiecărui elev. Să se afişeze elevii în ordinea descrescătoare a mediilor, iar pentru medii egale, în ordine alfabetică. #include\u0026lt;iostream.h\u0026gt;\n#include\u0026lt;conio.h\u0026gt;\n#define MAX 30\nstruct elev definirea structurii de date elev\n{char nume[MAX];\nint n1,n2;\nfloat media;\n};\nelev a[MAX]; a-tabl\n oul pentru memorarea elevilor\nint n;\nvoid citire() citire date\n{int i;\nclrscr();\nfor(i=1; i\u0026lt;=n; i++)\n{cout\u0026lt;\u0026lt;\u0026quot;numele persoanei:\u0026quot;; cin.get();cin.get(a[i].nume,20,\u0026rsquo;\\n\u0026rsquo;); citeste numele\ncout\u0026lt;\u0026lt;\u0026quot;nota1: \u0026quot;; cin\u0026gt;\u0026gt;a[i].n1; citeste notele\ncout\u0026lt;\u0026lt;\u0026quot;nota2: \u0026quot;; cin\u0026gt;\u0026gt;a[i].n2;\na[i].media=(((float)a[i].n1+a[i].n2)/2); calculeaza media\n}\n}\nvoid afisare() afiseaza datele elevilor\n{int i;\nfor(i=1; i\u0026lt;=n; i++)\ncout\u0026lt;\u0026lt;a[i].nume \u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;a[i].n1\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;a[i].n2\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;a[i].media\u0026lt;\u0026lt;endl;\ngetch();\n}\nvoid ordonare() ordoneaza elevii descrescator după medii, iar la medii egale alfabetic\n{int i,sw;\nelev aux;\ndo{\nsw=1;\nfor(i=1; i\u0026lt;n; i++)\nif((a[i+1].media\u0026gt;a[i].media)||(a[i+1].media==a[i].media \u0026amp;\u0026amp; strcmp(a[i+1].nume,a[i].nume)\u0026lt;0))\n{aux=a[i+1]; a[i+1]=a[i]; a[i]=aux; sw=0; }\n} while(!sw);\n}\nvoid main()\n{ clrscr(); \ncout\u0026lt;\u0026lt;\u0026quot;n=\u0026quot;;cin\u0026gt;\u0026gt;n; n-nr.elevi\ncitire(); clrscr(); afisare(); citeste datele elevilor\nordonare(); ordoneaza elevii\ncout\u0026lt;\u0026lt;\u0026quot;Elevii in ordinea descrescatoare a mediilor\u0026quot;\u0026lt;\u0026lt;endl;\nafisare(); afiseaza datele elevilor\ngetch();\n}\nFisa de lucru_tipul_struct.pdf\n\u0026lt;/div\u0026gt;   \n"
},
{
	"uri": "https://danielanicolae.com/programare/tipuri_de_date_foxpro/",
	"title": "Tipuri de Date in FoxPRO",
	"tags": [],
	"description": "",
	"content": "  Tipuri de date şi funcţii standardîn FoxPro\nDatele cu care lucrează FoxPro sunt de tip numeric, caracter, data calendaristică, logic. Asupra acestor tipuri de date s-au definit operaţii specifice şi au fost realizate funcţii standard dintre care cele mai des folosite vor fi explicate în continuare.\nFuncţii uzuale asupra tuturor tipurilor de date:\n MAX (\u0026lt;e1\u0026gt;,\u0026lt;e2\u0026gt;)\n calculează maximul dintre două valori \u0026lt;e1\u0026gt; şi \u0026lt;e2\u0026gt;\n   MIN (\u0026lt;e1\u0026gt;,\u0026lt;e2\u0026gt;)\n calculează minimul dintre două valori \u0026lt;e1\u0026gt; şi \u0026lt;e2\u0026gt;\n   TYPE(\u0026lt;eC\u0026gt;)\n întoarce litera corespunzătoare tipului de dată.\n   IIF(\u0026lt;eL\u0026gt;,\u0026lt;e1\u0026gt;,\u0026lt;e2\u0026gt;)\n întoarce \u0026lt;e1\u0026gt; dacă \u0026lt;eL\u0026gt; este adevărat şi \u0026lt;e2\u0026gt;în caz contrar\n   \nTipul numeric O mare parte a datelor prelucrate de calculator este reprezentată de numere, pentru a căror descriere se foloseşte tipul numeric. Cu toate că limbajul FoxPro este un limbaj orientat pe lucrul cu baze de date şi nu unul orientat pe calcule matematice, ştiinţifice, tipul numeric este imlementat astfel ăcât să permită realizarea majorităţii operaţiilor matematice întâlnite în practică.\nDe asemenea, sunt prevăzute o serie de funcţii matematice prin care se pot calcula funcţiile matematice elementare.\nOperanzii numerici care intervin în expresii pot fi:\n- câmpuri numerice ale unei baze de date;\n- funcţii care returnează valori numerice;\n- variabile de tip numeric;\n- constante numerice.\nOperatori care se aplică unor operanzi numerici, având ca rezultate tot valori numerice sunt : , ^ (ridicarea la putere), * ( înmulţire), / (împărţire), % (modulo, restul împărţirii), + (adunare), - scădere. Între două expresii numerice se pot aplica, de asemenea, operatori relaţionali, obţinându-se expresii logice.\nFuncţiile standard uzuale:**\n\n ABS (\u0026lt;eN\u0026gt;)\n calculează valoarea absolută din \u0026lt;eN\u0026gt;\n   SQRT (\u0026lt;eN\u0026gt;)\n calculează radical din \u0026lt;eN\u0026gt; (strict pozitiv)\n   ROUND (\u0026lt;eN1\u0026gt;,\u0026lt;eN2\u0026gt;)\n \u0026lt;eN1\u0026gt; este rotunjită la zecimala dată de \u0026lt;eN2\u0026gt;\n   MOD (\u0026lt;eN1\u0026gt;,\u0026lt;eN2\u0026gt;)\n calculează restul împărţirii întregi a lui \u0026lt;eN1\u0026gt; la \u0026lt;eN2\u0026gt;\n   INT (\u0026lt;eN\u0026gt;)\n întoarce un întreg rezultat prin trunchierea zecimalelor\n   CEILING (\u0026lt;eN\u0026gt;)\n întoarce cel mai mic întreg mai mare sau egal cu argumentul \u0026lt;eN\u0026gt;\n   FLOOR (\u0026lt;eN\u0026gt;)\n întoarce cel mai mare întreg mai mic sau egal cu argumentul \u0026lt;eN\u0026gt;\n   SIGN (\u0026lt;eN\u0026gt;)\n întoarce valoarea –1 pentru argument negativ, 1 pentru argument pozitiv şi 0 pentru argument nul.\n   RAND ()\n returnează un număr aleator în intervalul (0, 1)\n   STR (\u0026lt;eN1\u0026gt;[,\u0026lt;eN2\u0026gt; [,\u0026lt;eN3\u0026gt;]])\n conversia între tipul numeric şi tipul şir: \u0026lt;eN1\u0026gt; este numărul, \u0026lt;eN2\u0026gt; este lungimea, \u0026lt;eN3\u0026gt; numărul de poziţii pe care se va face reprezentarea părţii zecimale.\n   \nExemplu: \n? 2 / 3\n0, 67\nSET DECIMAL TO 4\n? 2 / 3\n0 , 6667\nExemple cu funcţii:\n? ABS ( a )\n400\n? SIGN ( - 32 )\n- 1\na = - 2 / 3\n? a = SIGN ( a ) * ABS ( a )\n. T .\n? INT ( 14 . 46 )\n14\n? INT ( - 2 . 25 )\n- 2\na = 14 . 46\n? a – INT ( a )\n0 . 46\na = - 2 . 25\n? a – INT ( a )\n- 0 . 25\n? CEILING ( 8 . 32 )\n9\n? CEILING ( -4 . 23 )\n- 4\n? FLOOR ( 8 . 32 )\n8\n? FLOOR ( - 4 . 23 )\n- 5\n? EXP ( 2 )\n7 . 39\n? LOG ( 2 )\n0 . 69\n? LOG 10 ( 2 )\n1 . 00\n? EXP ( LOG ( 3 ) )\n3 . 00\n? SQRT ( 2 )\n1 . 41\nTipul şir de caractere  Un şir de caractere reprezintă o mulţime ordonată de caractere care se tratează ca un tot unitar. Într-un şir de caractere ordinea acestora fiind esenţială, fiecărui caracter I se poate asocia un număr reprezentând poziţia aceastuia în cadrul şirului. \nNumărul caracterelor dintr-un şir reprezintă lungimea şirului. Un subşir al şirului dat repreuintă o porţiune din şir, începând de la o poziţie specificată şi de lungimea dată\nConstantele de tip şir de caractere se specifică prin mulţimea caracterelor care le compun, încadrate între apostrofuri simple sau duble ( la ambele capete trebuie să fie acelaşi tip de apostrof ). \nPentru a include unul dintre cele două delimitatoare într-un şir de caractere, mulţimea caracterelor ce alcătuiesc şirul va fi încadrată între delimitatorul de celălalt tip decât cel din şir. Dacă lungimea şirului este 0 obţinem şirul vid sau nul, care se specifică prin două apostrofuri consecutive fără spaţii sau alte caractere între ele.\nDatele de tip şir de caractere pot avea lungimea maxim 255 caractere ASCII şi se reprezintă intern câte un caracter pe octet în binar. \nOperaţii asupra datelor de tip şir:\n- concatenarea a două şiruri se realizează prin operatorii de concatenare (+, -); (+) realizează concatenarea a două şiruri; \nExemplu: “ strada _ “ + “ George _ Coşbuc “\nDupă evaluare, va avea valoarea:\n“ strada _ George _ Coşbuc “\nOperatorul (-) realizează concatenarea termenilor cu mutarea spaţiilor de la sfârşitul primului şir la sfârşitul şirului rezultat.\nExemplu: “ Salut “ - “ prieteni !“\nDupă evaluare, vom obţine şirul de caractere\n“ Salut prieteni ! “\nse observă că blancurile de la începutul şirului al doilea îşi păstrează poziţia în şir.\n- testarea apartenenţei unui şir la un alt şir este realizată prin operatorul ($); poate fi folosit în expresii logice.\nDe exemplu, expresia:\n“ calcul “ $ “ calculator “\neste adevărată, pe când expresia:\n“ calcule “ $ “ calculator “\nva fi evaluată la valoarea logică fals.\nCompararea şirurilor de caractere de lungimi diferite este controlată de comanda :\nSET EXACT ON / OFF\n\nÎn starea ON şirurile se compară de pe toată lungimea lor (cu excepţia spaţiilor de la sfârşitul şirului). În starea OFF se ia lungimea cea mai scurtă şi, dacă pe aceeaşi lungime şirurile sunt egale, rezultatul este .T..\nFuncţii uzuale asupra şirurilor\n SUBSTR (\u0026lt;eC\u0026gt;, \u0026lt;eN1\u0026gt;,\u0026lt;eN2\u0026gt;)\n extrage un subşir din şirul \u0026lt;eC\u0026gt; începând cu \ncaracterul de pe poziţia \u0026lt;eN1\u0026gt; pe lungime\n\u0026lt;eN2\u0026gt;\n   LEFT (\u0026lt;eC\u0026gt;, \u0026lt;eN\u0026gt;)\n extrage primele \u0026lt;eN\u0026gt; caractere din şirul \u0026lt;eC\u0026gt;\n   RIGHT (\u0026lt;eC\u0026gt;, \u0026lt;eN\u0026gt;)\n extrage ultimele \u0026lt;eN\u0026gt; caractere din şirul \u0026lt;eC\u0026gt;\n   LEN (\u0026lt;eC\u0026gt;)\n întoarce lungimea şirului \u0026lt;eC\u0026gt;\n   REPLICATE (\u0026lt;eC\u0026gt;, \u0026lt;eN\u0026gt;)\n întoarce un şir având \u0026lt;eC\u0026gt; multiplicat de \n\u0026lt;eN\u0026gt; ori\n   SPACE (\u0026lt;eN\u0026gt;)\n Întoarce un şir de \u0026lt;eN\u0026gt; spaţii\n   LTRIM (\u0026lt;eC\u0026gt;)\n elimină spaţiile de la stânga şirului \u0026lt;eC\u0026gt;\nex.: LTRIM(’MIA’)=”MIA”\n   RTRIM (\u0026lt;eC\u0026gt;)/ TRIM (\u0026lt;eC\u0026gt;)\n elimină spaţiile de la dreapta şirului \u0026lt;eC\u0026gt;\nex.: RTRIM(“MAI”’)=”MAI”\n   AT (\u0026lt;eC1\u0026gt;, \u0026lt;eC2\u0026gt;)\n întoarce poziţiile şirului \u0026lt;eC1\u0026gt; în \u0026lt;eC2\u0026gt;\n   ISALPHA (\u0026lt;eC\u0026gt;)\n testează dacă şirul începe cu o literă\n   ISLOWER (\u0026lt;eC\u0026gt;)\n testează dacă şirul începe cu minusculă\n   ISUPPER (\u0026lt;eC\u0026gt;)\n testează dacă şirul începe cu majusculă \n   LOWER (\u0026lt;eC\u0026gt;)\n transformă şirul în minuscule \n   UPPER (expC)\n transformă şirul în majuscule\n   STUFF (\u0026lt;eC1\u0026gt;,\u0026lt;eN1\u0026gt;, \u0026lt;eN2\u0026gt;, \u0026lt;eC2\u0026gt;)\n înlocuieşte în \u0026lt;eC1\u0026gt; începând cu poziţia \u0026lt;eN1\u0026gt; un subşir de lungime \u0026lt;eN2\u0026gt; prin şirul \u0026lt;eC2\u0026gt;\n   CTOD (\u0026lt;eC\u0026gt;)\n realizează conversia unui şir la data calendaristică \n   VAL (\u0026lt;eC\u0026gt;)\n realizează conversia unui şir la număr\n   Exemple:\n? CHR ( 49 ) \n1\n? CHR ( 65 ) == “ A “\n. T .\n? ASC ( “ A “ )\n65\n? ASC ( “ a “ ) = ASC ( alfa )\n. T .\n? “ A “ == CHR ( ASC ( “ A “ ) )\n. T .\n? 65 == ASC ( CHR ) 65 ) )\n. T .\n? SUBSTR ( “ ABCDEF “ , 2, 3 )\nBCD\n? SUBSTR ( “ Ziua Bună “ , 6 )\nBună\n? LEFT ( “ La mulţi ani ! “ , 2 )\nLa\n? RIGHT ( “ Noapte bună ! “ , 6 )\nbună !\n? REPLICATE ( “ a “ , 5 )\na a a a a \n? REPLICATE ( “ “ , 6 ) == SPACE ( 6 )\n. T .\n? ALLTRIM ( “ GAMA “ ) == “ GAMA “\n. T .\n? “ Mă numesc “ + RTRIM ( “ Ionescu “ ) + “ Daniel “\nMă numesc Ionescu Daniel\n? “ şi am “ + LTRIM ( “ 24 “ ) + “ ani. “\nşi am 24 ani\n? AT ( “ nr. “ , “ Strada George Coşbuc, nr. 63 – 64 “ )\n22\n? LEN ( “ Salutări ! “ )\n10\n? LEN ( “ Strada George Coşbuc “ + “ nr. 150 “ )\n27\na = “ ALFA “\nb = “ alfa “\n? UPPER ( a ) == UPPER ( b )\n. T .\n? LOWER ( a ) == LOWER ( b )\n. T .\nSTORE “ pala “ TO şir\nşir = STUFF ( şir , 3 , 0 , “ rale “ )\n? şir\nparalela\nşir = STUFF ( şir , 3 , 3 , “ sar “ )\n? şir\npasarela\nşir = STUFF ( şir , 7 , 2 , “ “ )\n? şir\npasare\nTipul dată calendaristică Datele calendaristice pot fi reprezentate în mai multe formate având ca delimitator acolada. Forma de prezentare a unei date calendaristice depinde de comanda SET DATE:\n SET DATE [TO] \u0026lt;format\u0026gt; \n   unde \u0026lt;format\u0026gt; poate fi: AMERICAN / GERMAN / ANSI / ITALIAN / DMY /BRITISH /JAPAN /FRENCH /USA /MDY /YMD\nFormatul AMERICAN prezintă data calendaristică sub forma: ll/zz/aa.; formatul GERMAN sub forma zz.ll.aa., etc.\nIncluderea secolului în formatul de dată este determinată de starea comutatorului SET CENTURY ON/OFF. Implicit este OFF.\nIndicarea semnului folosit ca separator al informaţiilor de tip dată calendaristică este dat de comanda SET MARK. Implicit separatorul este dat de formatul de reprezentare. De exemplu formatul AMERICAN foloseşte ca separator ”/”.\n SET DATE TO \u0026lt;car\u0026gt; \n   unde \u0026lt;car\u0026gt; reprezintă un singur caracter ce va fi folosit ca separator al informaţiilor din data calendaristică.\n\nOperaţii care se pot face cu datele calendaristice sunt:\n- compararea a două date se realizează prin operatorii relaţionali:\n- diferenţa dintre două date calendaristice returnează un număr de zile:\n- prin adunarea unui număr de zile la o dată calendaristică se obţine o altă dată:\n- prin scăderea unui număr dintr-o dată calendaristică se obţine tot o dată;\nFuncţiile referitoare la date calendaristice sunt :\n DATE()\n întoarce data curentă de la sistem\n   DAY (\u0026lt;eD\u0026gt;)\n extrage nr. zilei din dată\n   MONTH(\u0026lt;eD\u0026gt;)\n extrage nr. lunii din dată\n   CMONTH(\u0026lt;eD\u0026gt;)\n întoarce numele lunii \n   YEAR(\u0026lt;eD\u0026gt;)\n extrage anul din data calendaristică\n   TIME()\n extrage ora sistem sub forma şirului ‘HH:MM:SS’\n   DTOS(\u0026lt;eD\u0026gt;)\n întoarce data sub forma ‘secol – an lună zi’\n   DMY(\u0026lt;eD\u0026gt;)\n întoarce data sub forma ‘zi nume-lună an’\n   MDY(\u0026lt;eD\u0026gt;)\n întoarce data sub forma ‘nume – lună zi an’\n   DTOC(\u0026lt;eD\u0026gt;)\n conversie data la şir\n   Exemple: \n? DATE ( )\n11 / 12 / 2000\n? CDOW ( DATE ( ) )\nSaturday\n? DOW ( {10 / 02 / 1864} )\n1\n? DAY ( {03 / 14 / 1990} )\n14\n? MONTH ( DATE ( ) )\n3\n? CMONTH ( {03 / 25 / 1990} )\nMarch   \n"
},
{
	"uri": "https://danielanicolae.com/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://danielanicolae.com/",
	"title": "Daniela Liliana Nicolae",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://danielanicolae.com/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]